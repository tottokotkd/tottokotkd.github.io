{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/alpha-dust/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","path":"img/bg-pattern.png","modified":0,"renderable":1},{"_id":"themes/alpha-dust/source/js/main.js","path":"js/main.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1480774635000},{"_id":"themes/alpha-dust/.gitignore","hash":"2aa039aab52800662710bbf503671c770af96621","modified":1481431138000},{"_id":"themes/alpha-dust/LICENSE","hash":"20fb6ab02264ce4860e25cd70b50fa86c08f1cf8","modified":1481431138000},{"_id":"themes/alpha-dust/README.md","hash":"ab3d1d91ddca6223455022152e89fd4d0b41c851","modified":1481431138000},{"_id":"themes/alpha-dust/_config.yml","hash":"e945367afc029d74a2a149ea1cb58b99248ec7d6","modified":1481436428000},{"_id":"source/_drafts/20161203 オリジナルgulpfileを書くのは悪い文明.md","hash":"515bf7780b4ef1e69fcc334b6b4cdf1d2c40ad58","modified":1480822183000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1480691879000},{"_id":"source/_posts/20161120 サイト引っ越しとかいう死語について.md","hash":"6b8b46d4c450d8bd4931fa5c295af357468d39b1","modified":1480694443000},{"_id":"source/_posts/20161202 Swift + Kitura + MySQL + CLion + CMakeで頑張っている件.md","hash":"e0d1b57c3760a939d6a4b841aef0bc161d8f3074","modified":1480694642000},{"_id":"source/_posts/20161202 swift buildで渡すオプションをいちいち書きたくないのでcmakeする.md","hash":"459dd83fef24d9cff533dc3a4b6057e2d2d15e8c","modified":1480694642000},{"_id":"source/_posts/20161211 Kotlin + AWS Lambda + API GatewayでServerlessできちゃうラッパー公開したのでDynamoDBとか使っちゃう.md","hash":"628c7ffffc4925f51772ad0b05f29474eef15e0e","modified":1481436513000},{"_id":"themes/alpha-dust/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1481431138000},{"_id":"themes/alpha-dust/.git/config","hash":"d4dd417701b9cddba99958c69486c3d0f1faa162","modified":1481431138000},{"_id":"themes/alpha-dust/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1481431130000},{"_id":"themes/alpha-dust/.git/index","hash":"380cf4e986db947f7ba4fb51a80fbf5fa11dc5dd","modified":1481431138000},{"_id":"themes/alpha-dust/.git/packed-refs","hash":"78b1fd0f38dda2c458f7e05bf650c3f763e3cc62","modified":1481431138000},{"_id":"themes/alpha-dust/languages/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1481431138000},{"_id":"themes/alpha-dust/languages/default.yml","hash":"bc4b0f68c3579f8d9c217b96ae9d2da1991c92f7","modified":1481431138000},{"_id":"themes/alpha-dust/languages/en.yml","hash":"bc4b0f68c3579f8d9c217b96ae9d2da1991c92f7","modified":1481431138000},{"_id":"themes/alpha-dust/languages/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1481431138000},{"_id":"themes/alpha-dust/languages/fr.yml","hash":"e9e6f7cb362ebb7997f11027498a2748fe3bac95","modified":1481431138000},{"_id":"themes/alpha-dust/languages/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1481431138000},{"_id":"themes/alpha-dust/languages/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1481431138000},{"_id":"themes/alpha-dust/languages/pt.yml","hash":"1d0c3689eb32fe13f37f8f6f303af7624ebfbaf0","modified":1481431138000},{"_id":"themes/alpha-dust/languages/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1481431138000},{"_id":"themes/alpha-dust/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1481431138000},{"_id":"themes/alpha-dust/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1481431138000},{"_id":"themes/alpha-dust/layout/archive.ejs","hash":"535ea1205c3dd8782aa8dec64c5bb67a5e118be9","modified":1481431138000},{"_id":"themes/alpha-dust/layout/index.ejs","hash":"a3f94e4a627a83735b82d93694980e988a32d65e","modified":1481431138000},{"_id":"themes/alpha-dust/layout/layout.ejs","hash":"2655449a77b370284e6af41aa72c7d72660008fa","modified":1481431138000},{"_id":"themes/alpha-dust/layout/page.ejs","hash":"1f22cea6bb74aa654f6d6ad54b2acbc27f532939","modified":1481431138000},{"_id":"themes/alpha-dust/layout/post.ejs","hash":"5c6c8d3c249c64c4879276d12159a50d5b65b775","modified":1481431138000},{"_id":"themes/alpha-dust/template/archive.html","hash":"239ef36831f10f892ecdbf4438994d62cc973caa","modified":1481431138000},{"_id":"themes/alpha-dust/template/index.html","hash":"8f5f763e912a2f84306e3857b476c5cd1c048cb0","modified":1481431138000},{"_id":"themes/alpha-dust/template/post.html","hash":"8c586749ca621e6b24c07d792cb28c7827a0ed21","modified":1481431138000},{"_id":"themes/alpha-dust/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1481431130000},{"_id":"themes/alpha-dust/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1481431130000},{"_id":"themes/alpha-dust/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1481431130000},{"_id":"themes/alpha-dust/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1481431130000},{"_id":"themes/alpha-dust/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1481431130000},{"_id":"themes/alpha-dust/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1481431130000},{"_id":"themes/alpha-dust/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1481431130000},{"_id":"themes/alpha-dust/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1481431130000},{"_id":"themes/alpha-dust/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1481431130000},{"_id":"themes/alpha-dust/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1481431130000},{"_id":"themes/alpha-dust/.git/logs/HEAD","hash":"775728550013eb97c9025ecc8cd14199911d6e2a","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/after-footer.ejs","hash":"15d1d1376aabe398cce7d18ff4af41635970dd29","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/article-archive.ejs","hash":"460768ed91c4bf71199f01685d7af385354ffd28","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/article-long.ejs","hash":"b8b6ac1c5d7556fa8f7921f3427d4555b69f502b","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/article-short.ejs","hash":"ea8f30c58cc1a749d052a6ca20db56c046ad58cf","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/comments.ejs","hash":"423529d88d45e0a928f6cfadcf9aef27ccb63c13","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/footer.ejs","hash":"1723a9bebcafc39007f58f2fbce597a2836f8276","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/footer_categories.ejs","hash":"1831ae75b1deb1729e858b2cd83e32fff3a33f6f","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/footer_recent_posts.ejs","hash":"569addbbc7d548fca4986e09631489f8515280ff","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/gallery.ejs","hash":"80c3758b90fe6c197b52602456e2c4dcf7167847","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/google-analytics.ejs","hash":"4e6e8de9becea5a1636a4dcadcf7a10c06e2426e","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/head.ejs","hash":"668eca04a5e2ff2dbd2d99135b2a5428686e73d8","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/header.ejs","hash":"c189a234d36c6b5c51f814007d5d779bf42f0191","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/menu.ejs","hash":"452e31aa3016cdf9febfe5c2597a335417873f08","modified":1481431138000},{"_id":"themes/alpha-dust/layout/_partial/pagination.ejs","hash":"b9ec572a16d79cba2341211d7623cd04d2b6e521","modified":1481431138000},{"_id":"themes/alpha-dust/source/css/style.styl","hash":"81677e048b26229f0a734873e1e7b72589627f98","modified":1481431138000},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1481431138000},{"_id":"themes/alpha-dust/source/js/main.js","hash":"7ee829ab42cf4d81280d20b5d664759436b19075","modified":1481431138000},{"_id":"themes/alpha-dust/template/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1481431138000},{"_id":"themes/alpha-dust/template/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1481431138000},{"_id":"themes/alpha-dust/template/css/style.css","hash":"50bf62012aa42d76e71ef6c6d359e0c6b02f1f41","modified":1481431138000},{"_id":"themes/alpha-dust/template/css/style.styl","hash":"792ff84e3a2b75cbdc216c8b37089eff0c4ec6bc","modified":1481431138000},{"_id":"themes/alpha-dust/template/img/bg-pattern copy.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1481431138000},{"_id":"themes/alpha-dust/template/img/bg-pattern-blue.png","hash":"07016986a35c5bfc04c1599829d6a4798c966731","modified":1481431138000},{"_id":"themes/alpha-dust/template/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1481431138000},{"_id":"themes/alpha-dust/template/img/hex-bg.png","hash":"a8444a553dd0fd7db09eda830bd3346cc87fc60e","modified":1481431138000},{"_id":"themes/alpha-dust/template/js/main.js","hash":"656d203e231f4533d97654816ff285fcbdfd0956","modified":1481431138000},{"_id":"themes/alpha-dust/template/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1481431138000},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1481431138000},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1481431138000},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1481431138000},{"_id":"themes/alpha-dust/.git/refs/heads/master","hash":"7d9297b966a6f77c88162119c9a37350773868c4","modified":1481431138000},{"_id":"themes/alpha-dust/template/img/session_image.jpeg","hash":"5a3669c0564044f56cb7cea464119a8e388fb18f","modified":1481431138000},{"_id":"themes/alpha-dust/.git/objects/pack/pack-8284ad482fe97098d973e978d98c7760ba1d009d.idx","hash":"9a9bd06077855bf97b0c0d3732ae5286f2479316","modified":1481431138000},{"_id":"themes/alpha-dust/source/css/_partial/archive.styl","hash":"77f7b4341cb8d12191035150de6bb04635eb2a89","modified":1481431138000},{"_id":"themes/alpha-dust/source/css/_partial/base.styl","hash":"f01047771a92520cf318930331517f4c9e70c04a","modified":1481431138000},{"_id":"themes/alpha-dust/source/css/_partial/code.styl","hash":"3d2bbfef131c2f3fc5d44f54597da850ce29e2cf","modified":1481431138000},{"_id":"themes/alpha-dust/source/css/_partial/footer.styl","hash":"0a086dfb77bc55b27378f97e442e3a696f69048f","modified":1481431138000},{"_id":"themes/alpha-dust/source/css/_partial/header.styl","hash":"2e1e2ab562719127c7e216a49f8d7c02f9a0c2c4","modified":1481431138000},{"_id":"themes/alpha-dust/source/css/_partial/menu.styl","hash":"746c0bc7b37096b5f0f0a451c4783a054b22c309","modified":1481431138000},{"_id":"themes/alpha-dust/source/css/_partial/pagination.styl","hash":"2368cc9bd2404bce950b55fb2d9be3e7f1e1039c","modified":1481431138000},{"_id":"themes/alpha-dust/source/css/_partial/post-content.styl","hash":"117b655a4f0c78b3cb3fb7be3e09b829c1debc49","modified":1481431138000},{"_id":"themes/alpha-dust/source/css/_partial/post-layout.styl","hash":"b60fbbd78ca88d2174db1426cf941b6c998dd823","modified":1481431138000},{"_id":"themes/alpha-dust/source/css/_partial/variables.styl","hash":"789108805cf6d536b8a979a722b5b26a7e27fb28","modified":1481431138000},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1481431138000},{"_id":"themes/alpha-dust/.git/logs/refs/heads/master","hash":"775728550013eb97c9025ecc8cd14199911d6e2a","modified":1481431138000},{"_id":"themes/alpha-dust/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1481431138000},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1481431138000},{"_id":"themes/alpha-dust/.git/logs/refs/remotes/origin/HEAD","hash":"775728550013eb97c9025ecc8cd14199911d6e2a","modified":1481431138000},{"_id":"themes/alpha-dust/.git/objects/pack/pack-8284ad482fe97098d973e978d98c7760ba1d009d.pack","hash":"de24c8f29a02c2bbb28ff01c58db59590fb5c999","modified":1481431138000},{"_id":"public/atom.xml","hash":"adef2985c504486f07e01a77f101ac282ce02c1f","modified":1481436521810},{"_id":"public/2016/11/20/1/index.html","hash":"b2c122a0056fa726ca58effb8d503a404732f097","modified":1481436615671},{"_id":"public/archives/index.html","hash":"fd31e68c6ae9b691dce241ae3cf97137cda2019a","modified":1481436615669},{"_id":"public/archives/2016/index.html","hash":"ae2e2cf49dbabb032c65867cb2a9a75322e78c96","modified":1481436615671},{"_id":"public/archives/2016/11/index.html","hash":"d7d5cf2dc74de6737f8b0c8e1d19af748e384e95","modified":1481436615672},{"_id":"public/archives/2016/12/index.html","hash":"48286df763e23b94ace1f1a7e5d24b3c77868d7b","modified":1481436615672},{"_id":"public/tags/Swift/index.html","hash":"d8c9da5e22a8678e224174dc51bf378bd172d56f","modified":1481436457986},{"_id":"public/tags/Kitura/index.html","hash":"33978581875c5de4812c90c7f5436dec77fbf581","modified":1481436457986},{"_id":"public/tags/MariaDB/index.html","hash":"221ac75287eb3ff4b20a13dbe3ecb027ca73541b","modified":1481436457986},{"_id":"public/tags/Sterntaler/index.html","hash":"d1191af85ec72cf8db755c5ae51d597eeac7f87d","modified":1481436457986},{"_id":"public/tags/CLion/index.html","hash":"2e0470a5757380e7ae31bb7be65fe802dab76b22","modified":1481436457986},{"_id":"public/tags/CMake/index.html","hash":"0cd672ac95b04278b8c84273f0e7d020a60dfbc4","modified":1481436457987},{"_id":"public/2016/12/11/1/index.html","hash":"7dc157f21ced60d655b1888c38b65038dc92b22c","modified":1481436615672},{"_id":"public/2016/12/02/1/index.html","hash":"433fdaf89b7860b8c80cb5f22daa178436675250","modified":1481436615667},{"_id":"public/2016/11/22/1/index.html","hash":"dc4e58cd3bce179a9970f2e5a436096adea1788e","modified":1481436615673},{"_id":"public/index.html","hash":"a6deed7dd8d1e81044788467ede5c4b36289cd4a","modified":1481436457987},{"_id":"public/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1481436075887},{"_id":"public/css/style.css","hash":"a8b4312a0a6e600e3c1629df20e2860757370d10","modified":1481436076456},{"_id":"public/js/main.js","hash":"7ee829ab42cf4d81280d20b5d664759436b19075","modified":1481436076456},{"_id":"public/tags/Kotlin/index.html","hash":"d37e345e01a6d045d47cae03a4d29832583f63df","modified":1481436522039},{"_id":"public/tags/AWS/index.html","hash":"830ab6fe64b75070d822c1f165d2f59c986a6488","modified":1481436522039}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"オリジナルgulpfileを書くのは悪い文明","date":"2016-12-03T14:22:36.000Z","_content":"\n","source":"_drafts/20161203 オリジナルgulpfileを書くのは悪い文明.md","raw":"---\ntitle: オリジナルgulpfileを書くのは悪い文明\ndate: 2016-12-03 23:22:36\npermalink: 1\ntags:\n - Gulp\n---\n\n","slug":"1","published":0,"updated":"2016-12-04T03:29:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwk8sff70000dtc1ilq97zad","content":"","excerpt":"","more":""},{"title":"Swift + Kitura + MySQLで頑張っている件","date":"2016-12-02T03:33:13.000Z","_content":"\nこのコードをコピペすればswiftでmysqlサーバー叩いてJSON垂れ流せるぞ！ (実際に試したのはMariaDBだけど)\n\nまずパッケージね。試してないけどLinuxでも動く気がする。\n\n```swift\nimport PackageDescription\n\nlet package = Package(\n    name: \"nwsns\",\n    dependencies: [\n        .Package(url: \"https://github.com/IBM-Swift/Kitura.git\", majorVersion: 1, minor: 2),\n        .Package(url: \"https://github.com/tottokotkd/MariaDbTaler.git\", majorVersion: 0, minor: 1)\n    ])\n```\n\nそしてサーバー立てる。コードは超簡単だから説明不要ですねえ。\n\n```swift\nimport Foundation\nimport Sterntaler\nimport MariaDbTaler\nimport Kitura\nimport SwiftyJSON\n\n// Create a new router\nlet router = Router()\nlet pool = MariaDB.get(host: \"127.0.0.1\", user: \"root\", password: \"pass\", database: \"fosdb\")\nlet columns = (Columns.int(\"id\"), Columns.string(\"name\"), NullableColumns.date(\"day\"))\n\n// Handle HTTP GET requests to /\nrouter.get(\"/\") { request, response, next in\n    let data = pool.execute(sql: \"SELECT id, name, day FROM test\")\n        .map{$0.read(tuple: columns)}\n        .map{[\"id\": $0.0, \"name\": $0.1, \"day\": $0.2?.description ?? \"null\"]}\n    try! response.status(.OK).send(json: JSON(data)).end()\n    next()\n}\n\n// Add an HTTP server and connect it to the router\nKitura.addHTTPServer(onPort: 8090, with: router)\n\n// Start the Kitura runloop (this call never returns)\nKitura.run()\n```\n\nSterntaler / MariaDbTalerとかいうモジュールがMySQL Connector/Cの自作ラッパーです。ホントは劣化Slickみたいなすごいやつ作りたかったけど当然無理なので妥協しました。SQLインジェクション対策すらない時点で100%ダメなのですけど、でもなんだか既存のコードもしっくり来なくて… \n\nちなみにプールとか言ってますが勿論ウソです。毎回つないでます。\n\n\nこれを動かす場合、`brew install mariadb`でMariaDBを入れて、それっぽいデータベースとテーブル作って、`swift build -Xlinker -L/usr/local/lib -Xcc -I/usr/local/include -Xswiftc -lmysqlclient`でビルドすれば動く気がします。もちろんKituraの依存ライブラリーも入れましょう。\n\nちなみに、いま世間にいくつかあるSwift系mysqlライブラリーにはOpenSSLが入っていないとビルドできないものがあるみたいです。ところがOpenSSLをbrewでインストールするとリンク段階で失敗することがあるので、その場合ビルドするときには`-Xcc -I/usr/local/opt/openssl/include -Xlinker -L/usr/local/opt/openssl/lib`とか指定するといいです。たぶん。\n\n（それらはGPLに静的リンクしているような気がするけど調べてません）\n\nこの方向で何かちょっと動くものを作れるか頑張ってます。しかし実際どうなるかはわかんない。","source":"_posts/20161202 Swift + Kitura + MySQL + CLion + CMakeで頑張っている件.md","raw":"---\ntitle: Swift + Kitura + MySQLで頑張っている件\ndate: 2016-12-02 12:33:13\npermalink: 1\ntags:\n- Swift\n- Kitura\n- MariaDB\n- Sterntaler\n---\n\nこのコードをコピペすればswiftでmysqlサーバー叩いてJSON垂れ流せるぞ！ (実際に試したのはMariaDBだけど)\n\nまずパッケージね。試してないけどLinuxでも動く気がする。\n\n```swift\nimport PackageDescription\n\nlet package = Package(\n    name: \"nwsns\",\n    dependencies: [\n        .Package(url: \"https://github.com/IBM-Swift/Kitura.git\", majorVersion: 1, minor: 2),\n        .Package(url: \"https://github.com/tottokotkd/MariaDbTaler.git\", majorVersion: 0, minor: 1)\n    ])\n```\n\nそしてサーバー立てる。コードは超簡単だから説明不要ですねえ。\n\n```swift\nimport Foundation\nimport Sterntaler\nimport MariaDbTaler\nimport Kitura\nimport SwiftyJSON\n\n// Create a new router\nlet router = Router()\nlet pool = MariaDB.get(host: \"127.0.0.1\", user: \"root\", password: \"pass\", database: \"fosdb\")\nlet columns = (Columns.int(\"id\"), Columns.string(\"name\"), NullableColumns.date(\"day\"))\n\n// Handle HTTP GET requests to /\nrouter.get(\"/\") { request, response, next in\n    let data = pool.execute(sql: \"SELECT id, name, day FROM test\")\n        .map{$0.read(tuple: columns)}\n        .map{[\"id\": $0.0, \"name\": $0.1, \"day\": $0.2?.description ?? \"null\"]}\n    try! response.status(.OK).send(json: JSON(data)).end()\n    next()\n}\n\n// Add an HTTP server and connect it to the router\nKitura.addHTTPServer(onPort: 8090, with: router)\n\n// Start the Kitura runloop (this call never returns)\nKitura.run()\n```\n\nSterntaler / MariaDbTalerとかいうモジュールがMySQL Connector/Cの自作ラッパーです。ホントは劣化Slickみたいなすごいやつ作りたかったけど当然無理なので妥協しました。SQLインジェクション対策すらない時点で100%ダメなのですけど、でもなんだか既存のコードもしっくり来なくて… \n\nちなみにプールとか言ってますが勿論ウソです。毎回つないでます。\n\n\nこれを動かす場合、`brew install mariadb`でMariaDBを入れて、それっぽいデータベースとテーブル作って、`swift build -Xlinker -L/usr/local/lib -Xcc -I/usr/local/include -Xswiftc -lmysqlclient`でビルドすれば動く気がします。もちろんKituraの依存ライブラリーも入れましょう。\n\nちなみに、いま世間にいくつかあるSwift系mysqlライブラリーにはOpenSSLが入っていないとビルドできないものがあるみたいです。ところがOpenSSLをbrewでインストールするとリンク段階で失敗することがあるので、その場合ビルドするときには`-Xcc -I/usr/local/opt/openssl/include -Xlinker -L/usr/local/opt/openssl/lib`とか指定するといいです。たぶん。\n\n（それらはGPLに静的リンクしているような気がするけど調べてません）\n\nこの方向で何かちょっと動くものを作れるか頑張ってます。しかし実際どうなるかはわかんない。","slug":"1","published":1,"updated":"2016-12-02T16:04:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwk8sffd0001dtc1ilp3owlw","content":"<p>このコードをコピペすればswiftでmysqlサーバー叩いてJSON垂れ流せるぞ！ (実際に試したのはMariaDBだけど)</p>\n<p>まずパッケージね。試してないけどLinuxでも動く気がする。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> PackageDescription</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> package = <span class=\"type\">Package</span>(</div><div class=\"line\">    name: <span class=\"string\">\"nwsns\"</span>,</div><div class=\"line\">    dependencies: [</div><div class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/IBM-Swift/Kitura.git\"</span>, majorVersion: <span class=\"number\">1</span>, minor: <span class=\"number\">2</span>),</div><div class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/tottokotkd/MariaDbTaler.git\"</span>, majorVersion: <span class=\"number\">0</span>, minor: <span class=\"number\">1</span>)</div><div class=\"line\">    ])</div></pre></td></tr></table></figure>\n<p>そしてサーバー立てる。コードは超簡単だから説明不要ですねえ。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Foundation</div><div class=\"line\"><span class=\"keyword\">import</span> Sterntaler</div><div class=\"line\"><span class=\"keyword\">import</span> MariaDbTaler</div><div class=\"line\"><span class=\"keyword\">import</span> Kitura</div><div class=\"line\"><span class=\"keyword\">import</span> SwiftyJSON</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Create a new router</span></div><div class=\"line\"><span class=\"keyword\">let</span> router = <span class=\"type\">Router</span>()</div><div class=\"line\"><span class=\"keyword\">let</span> pool = <span class=\"type\">MariaDB</span>.<span class=\"keyword\">get</span>(host: <span class=\"string\">\"127.0.0.1\"</span>, user: <span class=\"string\">\"root\"</span>, password: <span class=\"string\">\"pass\"</span>, database: <span class=\"string\">\"fosdb\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> columns = (<span class=\"type\">Columns</span>.int(<span class=\"string\">\"id\"</span>), <span class=\"type\">Columns</span>.string(<span class=\"string\">\"name\"</span>), <span class=\"type\">NullableColumns</span>.date(<span class=\"string\">\"day\"</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Handle HTTP GET requests to /</span></div><div class=\"line\">router.<span class=\"keyword\">get</span>(<span class=\"string\">\"/\"</span>) &#123; request, response, next <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">let</span> data = pool.execute(sql: <span class=\"string\">\"SELECT id, name, day FROM test\"</span>)</div><div class=\"line\">        .<span class=\"built_in\">map</span>&#123;$<span class=\"number\">0</span>.read(tuple: columns)&#125;</div><div class=\"line\">        .<span class=\"built_in\">map</span>&#123;[<span class=\"string\">\"id\"</span>: $<span class=\"number\">0.0</span>, <span class=\"string\">\"name\"</span>: $<span class=\"number\">0.1</span>, <span class=\"string\">\"day\"</span>: $<span class=\"number\">0.2</span>?.description ?? <span class=\"string\">\"null\"</span>]&#125;</div><div class=\"line\">    <span class=\"keyword\">try</span>! response.status(.<span class=\"type\">OK</span>).send(json: <span class=\"type\">JSON</span>(data)).end()</div><div class=\"line\">    next()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Add an HTTP server and connect it to the router</span></div><div class=\"line\"><span class=\"type\">Kitura</span>.addHTTPServer(onPort: <span class=\"number\">8090</span>, with: router)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Start the Kitura runloop (this call never returns)</span></div><div class=\"line\"><span class=\"type\">Kitura</span>.run()</div></pre></td></tr></table></figure>\n<p>Sterntaler / MariaDbTalerとかいうモジュールがMySQL Connector/Cの自作ラッパーです。ホントは劣化Slickみたいなすごいやつ作りたかったけど当然無理なので妥協しました。SQLインジェクション対策すらない時点で100%ダメなのですけど、でもなんだか既存のコードもしっくり来なくて… </p>\n<p>ちなみにプールとか言ってますが勿論ウソです。毎回つないでます。</p>\n<p>これを動かす場合、<code>brew install mariadb</code>でMariaDBを入れて、それっぽいデータベースとテーブル作って、<code>swift build -Xlinker -L/usr/local/lib -Xcc -I/usr/local/include -Xswiftc -lmysqlclient</code>でビルドすれば動く気がします。もちろんKituraの依存ライブラリーも入れましょう。</p>\n<p>ちなみに、いま世間にいくつかあるSwift系mysqlライブラリーにはOpenSSLが入っていないとビルドできないものがあるみたいです。ところがOpenSSLをbrewでインストールするとリンク段階で失敗することがあるので、その場合ビルドするときには<code>-Xcc -I/usr/local/opt/openssl/include -Xlinker -L/usr/local/opt/openssl/lib</code>とか指定するといいです。たぶん。</p>\n<p>（それらはGPLに静的リンクしているような気がするけど調べてません）</p>\n<p>この方向で何かちょっと動くものを作れるか頑張ってます。しかし実際どうなるかはわかんない。</p>\n","excerpt":"","more":"<p>このコードをコピペすればswiftでmysqlサーバー叩いてJSON垂れ流せるぞ！ (実際に試したのはMariaDBだけど)</p>\n<p>まずパッケージね。試してないけどLinuxでも動く気がする。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> PackageDescription</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> package = <span class=\"type\">Package</span>(</div><div class=\"line\">    name: <span class=\"string\">\"nwsns\"</span>,</div><div class=\"line\">    dependencies: [</div><div class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/IBM-Swift/Kitura.git\"</span>, majorVersion: <span class=\"number\">1</span>, minor: <span class=\"number\">2</span>),</div><div class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/tottokotkd/MariaDbTaler.git\"</span>, majorVersion: <span class=\"number\">0</span>, minor: <span class=\"number\">1</span>)</div><div class=\"line\">    ])</div></pre></td></tr></table></figure>\n<p>そしてサーバー立てる。コードは超簡単だから説明不要ですねえ。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Foundation</div><div class=\"line\"><span class=\"keyword\">import</span> Sterntaler</div><div class=\"line\"><span class=\"keyword\">import</span> MariaDbTaler</div><div class=\"line\"><span class=\"keyword\">import</span> Kitura</div><div class=\"line\"><span class=\"keyword\">import</span> SwiftyJSON</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Create a new router</span></div><div class=\"line\"><span class=\"keyword\">let</span> router = <span class=\"type\">Router</span>()</div><div class=\"line\"><span class=\"keyword\">let</span> pool = <span class=\"type\">MariaDB</span>.<span class=\"keyword\">get</span>(host: <span class=\"string\">\"127.0.0.1\"</span>, user: <span class=\"string\">\"root\"</span>, password: <span class=\"string\">\"pass\"</span>, database: <span class=\"string\">\"fosdb\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> columns = (<span class=\"type\">Columns</span>.int(<span class=\"string\">\"id\"</span>), <span class=\"type\">Columns</span>.string(<span class=\"string\">\"name\"</span>), <span class=\"type\">NullableColumns</span>.date(<span class=\"string\">\"day\"</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Handle HTTP GET requests to /</span></div><div class=\"line\">router.<span class=\"keyword\">get</span>(<span class=\"string\">\"/\"</span>) &#123; request, response, next <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">let</span> data = pool.execute(sql: <span class=\"string\">\"SELECT id, name, day FROM test\"</span>)</div><div class=\"line\">        .<span class=\"built_in\">map</span>&#123;$<span class=\"number\">0</span>.read(tuple: columns)&#125;</div><div class=\"line\">        .<span class=\"built_in\">map</span>&#123;[<span class=\"string\">\"id\"</span>: $<span class=\"number\">0.0</span>, <span class=\"string\">\"name\"</span>: $<span class=\"number\">0.1</span>, <span class=\"string\">\"day\"</span>: $<span class=\"number\">0.2</span>?.description ?? <span class=\"string\">\"null\"</span>]&#125;</div><div class=\"line\">    <span class=\"keyword\">try</span>! response.status(.<span class=\"type\">OK</span>).send(json: <span class=\"type\">JSON</span>(data)).end()</div><div class=\"line\">    next()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Add an HTTP server and connect it to the router</span></div><div class=\"line\"><span class=\"type\">Kitura</span>.addHTTPServer(onPort: <span class=\"number\">8090</span>, with: router)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Start the Kitura runloop (this call never returns)</span></div><div class=\"line\"><span class=\"type\">Kitura</span>.run()</div></pre></td></tr></table></figure>\n<p>Sterntaler / MariaDbTalerとかいうモジュールがMySQL Connector/Cの自作ラッパーです。ホントは劣化Slickみたいなすごいやつ作りたかったけど当然無理なので妥協しました。SQLインジェクション対策すらない時点で100%ダメなのですけど、でもなんだか既存のコードもしっくり来なくて… </p>\n<p>ちなみにプールとか言ってますが勿論ウソです。毎回つないでます。</p>\n<p>これを動かす場合、<code>brew install mariadb</code>でMariaDBを入れて、それっぽいデータベースとテーブル作って、<code>swift build -Xlinker -L/usr/local/lib -Xcc -I/usr/local/include -Xswiftc -lmysqlclient</code>でビルドすれば動く気がします。もちろんKituraの依存ライブラリーも入れましょう。</p>\n<p>ちなみに、いま世間にいくつかあるSwift系mysqlライブラリーにはOpenSSLが入っていないとビルドできないものがあるみたいです。ところがOpenSSLをbrewでインストールするとリンク段階で失敗することがあるので、その場合ビルドするときには<code>-Xcc -I/usr/local/opt/openssl/include -Xlinker -L/usr/local/opt/openssl/lib</code>とか指定するといいです。たぶん。</p>\n<p>（それらはGPLに静的リンクしているような気がするけど調べてません）</p>\n<p>この方向で何かちょっと動くものを作れるか頑張ってます。しかし実際どうなるかはわかんない。</p>\n"},{"title":"サイト引っ越しとかいう死語について","date":"2016-11-20T07:45:39.000Z","_content":"\n昔はよく言いましたよねえ、サイトのお引越し。この5年ほどですっかり聞かなくなった印象があります。\n\n「無償ブログサービスを渡り歩く人が減った」とか、「個人がドメインを持つのが当たり前になった」とか、「Webサイトを持つこと自体が流行らなくなった」とか、まあ色々と理由はありそうですね。知らんけど。\n\n私なんかは割と「タグ手打ちで工事中」みたいなレトロな世界に馴染みのある人間なんですけど、あの頃は大変だったですねえ… なにしろ世界中で車輪を再発名してましたもんね。今ならtwitterとfacebookでアカウント作って終わりだもん、そりゃインターネットも別世界になるよなあと。\n\nそこで僕も人類の進歩に便乗し、コマンド一発でブログ作れちゃう[Hexo](https://hexo.io/)くんのチカラを使ってみました。ただ現状サーバー料金を払う金がないので、関連するリソースはすべて[github](https://github.com/tottokotkd/tottokotkd.github.io)くんにあります。完全にタダ乗りだけど、なんか技術っぽい記事をたまに書けば許されると思います。\n\n今ぼんやり考えているのはツイッター関係で一つ、ニュース関係でもう一つ、CUIツールでさらに一つ… でもまあ多分しばらく形にならないので、やむを得ず、本当に仕方なく、どうしても嫌なんだけど不本意ながら、ただの日記みたいな記事を書きます。嗚呼残念だナ。\n\nなおHexo / github関連の記事は書かない。参考情報が沢山あるから今更追加する必要もない。","source":"_posts/20161120 サイト引っ越しとかいう死語について.md","raw":"---\ntitle: サイト引っ越しとかいう死語について\ndate: 2016-11-20 16:45:39\npermalink: 1\ntags:\n---\n\n昔はよく言いましたよねえ、サイトのお引越し。この5年ほどですっかり聞かなくなった印象があります。\n\n「無償ブログサービスを渡り歩く人が減った」とか、「個人がドメインを持つのが当たり前になった」とか、「Webサイトを持つこと自体が流行らなくなった」とか、まあ色々と理由はありそうですね。知らんけど。\n\n私なんかは割と「タグ手打ちで工事中」みたいなレトロな世界に馴染みのある人間なんですけど、あの頃は大変だったですねえ… なにしろ世界中で車輪を再発名してましたもんね。今ならtwitterとfacebookでアカウント作って終わりだもん、そりゃインターネットも別世界になるよなあと。\n\nそこで僕も人類の進歩に便乗し、コマンド一発でブログ作れちゃう[Hexo](https://hexo.io/)くんのチカラを使ってみました。ただ現状サーバー料金を払う金がないので、関連するリソースはすべて[github](https://github.com/tottokotkd/tottokotkd.github.io)くんにあります。完全にタダ乗りだけど、なんか技術っぽい記事をたまに書けば許されると思います。\n\n今ぼんやり考えているのはツイッター関係で一つ、ニュース関係でもう一つ、CUIツールでさらに一つ… でもまあ多分しばらく形にならないので、やむを得ず、本当に仕方なく、どうしても嫌なんだけど不本意ながら、ただの日記みたいな記事を書きます。嗚呼残念だナ。\n\nなおHexo / github関連の記事は書かない。参考情報が沢山あるから今更追加する必要もない。","slug":"1","published":1,"updated":"2016-12-02T16:00:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwk8sffi0003dtc154lwso9x","content":"<p>昔はよく言いましたよねえ、サイトのお引越し。この5年ほどですっかり聞かなくなった印象があります。</p>\n<p>「無償ブログサービスを渡り歩く人が減った」とか、「個人がドメインを持つのが当たり前になった」とか、「Webサイトを持つこと自体が流行らなくなった」とか、まあ色々と理由はありそうですね。知らんけど。</p>\n<p>私なんかは割と「タグ手打ちで工事中」みたいなレトロな世界に馴染みのある人間なんですけど、あの頃は大変だったですねえ… なにしろ世界中で車輪を再発名してましたもんね。今ならtwitterとfacebookでアカウント作って終わりだもん、そりゃインターネットも別世界になるよなあと。</p>\n<p>そこで僕も人類の進歩に便乗し、コマンド一発でブログ作れちゃう<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>くんのチカラを使ってみました。ただ現状サーバー料金を払う金がないので、関連するリソースはすべて<a href=\"https://github.com/tottokotkd/tottokotkd.github.io\" target=\"_blank\" rel=\"external\">github</a>くんにあります。完全にタダ乗りだけど、なんか技術っぽい記事をたまに書けば許されると思います。</p>\n<p>今ぼんやり考えているのはツイッター関係で一つ、ニュース関係でもう一つ、CUIツールでさらに一つ… でもまあ多分しばらく形にならないので、やむを得ず、本当に仕方なく、どうしても嫌なんだけど不本意ながら、ただの日記みたいな記事を書きます。嗚呼残念だナ。</p>\n<p>なおHexo / github関連の記事は書かない。参考情報が沢山あるから今更追加する必要もない。</p>\n","excerpt":"","more":"<p>昔はよく言いましたよねえ、サイトのお引越し。この5年ほどですっかり聞かなくなった印象があります。</p>\n<p>「無償ブログサービスを渡り歩く人が減った」とか、「個人がドメインを持つのが当たり前になった」とか、「Webサイトを持つこと自体が流行らなくなった」とか、まあ色々と理由はありそうですね。知らんけど。</p>\n<p>私なんかは割と「タグ手打ちで工事中」みたいなレトロな世界に馴染みのある人間なんですけど、あの頃は大変だったですねえ… なにしろ世界中で車輪を再発名してましたもんね。今ならtwitterとfacebookでアカウント作って終わりだもん、そりゃインターネットも別世界になるよなあと。</p>\n<p>そこで僕も人類の進歩に便乗し、コマンド一発でブログ作れちゃう<a href=\"https://hexo.io/\">Hexo</a>くんのチカラを使ってみました。ただ現状サーバー料金を払う金がないので、関連するリソースはすべて<a href=\"https://github.com/tottokotkd/tottokotkd.github.io\">github</a>くんにあります。完全にタダ乗りだけど、なんか技術っぽい記事をたまに書けば許されると思います。</p>\n<p>今ぼんやり考えているのはツイッター関係で一つ、ニュース関係でもう一つ、CUIツールでさらに一つ… でもまあ多分しばらく形にならないので、やむを得ず、本当に仕方なく、どうしても嫌なんだけど不本意ながら、ただの日記みたいな記事を書きます。嗚呼残念だナ。</p>\n<p>なおHexo / github関連の記事は書かない。参考情報が沢山あるから今更追加する必要もない。</p>\n"},{"title":"Kotlin + AWS Lambda + API GatewayでServerlessできちゃうラッパー公開したのでDynamoDBとか使っちゃう","date":"2016-12-11T03:36:08.000Z","_content":"\nタイトルの通りです。[githubに置いてある](https://github.com/tottokotkd/GatewayHandler)し、[Bintray経由でjcenterにもある](https://bintray.com/bintray/jcenter?filterByPkgName=GatewayHandler)ので使えます。この公開ルートは今回初めてやってみましたが、なかなか便利ですね。\n\nもちろん公開するだけならgithubページでもイケるんですけど、その作業が手間だったり、IntelliJくんがキャッシュ持つ段階でエラー吐いたり、面倒なのでBintrayです。今はあんまりそこを頑張りたくなかった、仕方なかった。\n\ngithubの方に書いてあるんですけど、コードでいうとこんな感じ。\n\n```kotlin\npackage hello\n\nimport com.amazonaws.regions.Regions\nimport com.amazonaws.services.dynamodbv2.document.DynamoDB\nimport com.amazonaws.services.dynamodbv2.document.Item\nimport com.amazonaws.services.lambda.runtime.Context\nimport com.tottokotkd.aws.gateway.core.*\nimport java.time.ZonedDateTime\nimport java.time.format.DateTimeFormatter\nimport kotlin.properties.Delegates\n\nclass SaveRequest {\n    lateinit var user: String\n    lateinit var url: String\n    var rate: Int by Delegates.notNull()\n    lateinit var timestamp: String\n}\n\nclass SaveHandler: DataHandler<SaveRequest, Any> {\n    override fun handleRequest(input: SaveRequest, context: Context): ResponseData<Any> {\n\n        val timestamp = try {\n            ZonedDateTime.parse(input.timestamp, DateTimeFormatter.ISO_DATE_TIME)\n        } catch (e: Exception) {\n            return ResponseData(mapOf(\"status\" to \"error\", \"desc\" to \"date time parsing failed.\"), StatusCode.BadRequest)\n        }\n\n        val dynamoDB = DynamoDB(Regions.US_EAST_1)\n        val t = dynamoDB.getTable(\"pages\")\n        val item = Item.fromMap(mapOf(\"user\" to input.user, \"url\" to input.url, \"rate\" to input.rate, \"epoch\" to timestamp.toEpochSecond(), \"timezone\" to timestamp.offset.totalSeconds))\n        val result = t.putItem(item)\n\n        return ResponseData(mapOf(\"status\" to \"success\", \"input\" to input))\n    }\n}\n```\n\n`SaveHandler`がリクエストハンドラーで、`SaveRequest`がリクエストに期待される内容ですね。言うまでもないか。\n\nAPI Gateway経由なのでJSONを渡されそうなものですが、実際はアマゾンがPOJOに突っ込んだうえで渡してくれます。Serverlessの設定として書くべきことも特になくて、本当にこのままLambdaにデプロイすれば面倒をみてくれます。DynamoDBもIAMさえ弄ればコードは1行で終わり。たったこれだけで (金さえ払えば) 無敵のスケーラビリティが手に入っちゃう。スゴイ！\n\nただしアマゾン様といえどもdata classのコンストラクタを使うような器用な芸当は当然やれないので、`SaveRequest`はプロパティ全てvarのクラスになっています。もっともここは`val hoge: String by Delegates.notNull()` の方がいいような気もするし、Web APIなんだから`String?`の方がかえってロジカルに書きやすいような気もするし、その辺りは僕もまだ深く考えてません。そこまでkotlinやAWSの挙動に詳しくないという事情もある。\n\nそれはともかく戻り値が`Any`になっていて許せん！という人もいると思いますが、これはmapOfで手軽に返したかったのです。データクラスとか指定すればちゃんと型安全で動きます (たぶん)。\n\nまあこの辺りは趣味の問題でもあり、生産性を上げるために工夫のしどころだとも思うので、`ResponseData`を使わず自前で実装する方がいいかもですね、ステータスコードは引数じゃなくて型に結びつけるとか。あるいはハンドラーの方にヘルパーをバシバシ生やすとか… その辺は今後ちょっと便利になったらいいかなあ。フォークしてPRで見せびらかしてくれる人とか出てきたら嬉しい。\n\n\n\nで、コードはもう特に書くことないので思い出をつらつらと。\n\n## API Gateway -> Lambda -> Error!\n\n`sls invoke -f hello` が動くぞ！やったー！などと隙を見せたエンジニアを強襲するAWS！\n\n> Malformed Lambda proxy response\n\nlambdaとしては呼べるけどcurlすると落ちる。\n\nServerless使って一番つらかったのはコレ。Kotlin + Serverless + API Gatewayなんて実際に使っているケースがほぼ見つからない上に、ちょっと古い記事だと「動きました！簡単」とか書いてあるコードが今はもう動かない。嘘だゾ、全然簡単じゃないゾ。\n\n\nということで頑張って検索して探したのがコレ。~~人柱サンキュー！~~\n\n{% blockquote kyl191 https://forums.aws.amazon.com/thread.jspa?threadID=239688 AWS Developer Forums: Lambda Proxy Expectations %}\nOk, I found some documentation which says it expects statusCode, body and headers in a dict.\n{% endblockquote %}\n\n何でこんな状態なのか、ちょっと意味が分からないんですけど、API Gateway (Lambda Proxy) から呼ばれるLambdaは**戻り値の型はどうでもいいしインターフェイスとかないけど、statusCode body headersという3つの値を持っていないと実行時エラーになる**という凡そJavaとは思われない動的な仕組みになっているみたいです。\n\nつまり、'sls invoke -f hello'の結果として\n\n```json\n{\"hage\": [\"ok\", \"cool\", \"amazing\"]}\n```\n\nみたいな結果が見えている場合はダメです。\n\nLambdaとしては動いているのですが、Gateway経由で呼びたいなら以下の内容でなければいけません。\n\n\n```json\n{\n    \"body\": {\n        \"hage\": [\"ok\", \"cool\", \"amazing\"]\n    },\n    \"headers\": {},\n    \"statusCode\": 400\n}\n```\n\nこのフォーマットを守らなければ、Lambda ProxyモードのAPI Gatewayは有効な結果として受け付けてくれないのです。理屈が分かってしまえば納得できますが、この落とし穴だけは本当にひどい罠だと思います。\n\n一旦Lambda側からJSONを出力した上で、それを改めてGateway側がチェックするんでしょうか？ 色々と想像してますが謎です。\n\nちなみにデータのJSON化はあっちがJacksonでやってくれるので、上記のようなプロパティを持つPOJOを投げればいいみたいです。kotlinならdata classですね。あと試していませんがmapでも大丈夫かなと。\n\nただまあ、そこを自由にしても特に利点がなさそうなうえ、誰の目にも明らかにバグの温床でしかありません。今回のラッパーでは3つのプロパティを明示的に要求するインターフェイスを作っておきました。そもそも本来こういう仕様になってなきゃJavaコードとしておかしいと思うんですけど、それはそれで公式SDKとしては狭すぎる感じもありますからね… まあ気持ちはわかります。クソですけど。\n\nLambdaプロキシ自体が割と新しい機能であることも考えると仕方ない、AWSはこういうものなのだ… と割り切りましょう。\n\n## 2つの型パラメータを持つジェネリッククラスでないとエラーになる\n\nもうエラーログが手元にないんですが、リクエストハンドラーとして型パラメータ1つのクラスを作ってみたら「型パラメータは2つないと困るんだよなァ！」みたいな激おこメッセージを飛ばしてきました。これまたちょっと意味が分からないんですけど、JSONをリクエストPOJOに変換するときに型パラメータを使おうとしているのかな？ とにかくダメなものはダメらしいです。\n\nそれにしたって型パラメータ2つじゃないとダメっておかしくねえか？設計どうなってんの？という気もしますが仕方ない、AWSはこういうものなのだ… と割り切りましょう。\n\n## Internal Server Error\nAPI Gatewayを通過して結果が戻ってくるまでの間にエラーが発生するとInternal Server Errorです。例えば「Lambda処理内でリクエストパラメータを参照したらnull例外で落ちた」とかいう場合、それはInternal Server Errorであり、Gatewayのデフォルト処理が走って超ダサいJSONを投げ返します。\n\nサーバー内部でエラーが発生するなら、API Gatewayの視点からは全てInternal Server Errorなのです。まあそりゃ当然の挙動なんですけど、それはAPIを書く側からするとBadRequestだし、そもそも勝手にダサいJSONを流されるのも困ります。\n\nということでつまり、ハンドラ全体をtryで囲わないと不安だし、リクエスト内容の処理もちゃんと書かないといけません。当たり前の話とはいえ若干ちょっと面倒そう…\n\nその辺りをうまく集約できるインターフェイスとか作らないと大変そうですね。まあもちろん「ステータスコードさえ取れるなら大丈夫、後はYAGNI」という考え方もあると思います。その辺りの線引きはちょっと難しそう。\n\n## ということで\n\nなんか動くものは作れそうだし頑張る。","source":"_posts/20161211 Kotlin + AWS Lambda + API GatewayでServerlessできちゃうラッパー公開したのでDynamoDBとか使っちゃう.md","raw":"---\ntitle: Kotlin + AWS Lambda + API GatewayでServerlessできちゃうラッパー公開したのでDynamoDBとか使っちゃう\npermalink: 1\ndate: 2016-12-11 12:36:08\ntags:\n- Kotlin\n- AWS\n---\n\nタイトルの通りです。[githubに置いてある](https://github.com/tottokotkd/GatewayHandler)し、[Bintray経由でjcenterにもある](https://bintray.com/bintray/jcenter?filterByPkgName=GatewayHandler)ので使えます。この公開ルートは今回初めてやってみましたが、なかなか便利ですね。\n\nもちろん公開するだけならgithubページでもイケるんですけど、その作業が手間だったり、IntelliJくんがキャッシュ持つ段階でエラー吐いたり、面倒なのでBintrayです。今はあんまりそこを頑張りたくなかった、仕方なかった。\n\ngithubの方に書いてあるんですけど、コードでいうとこんな感じ。\n\n```kotlin\npackage hello\n\nimport com.amazonaws.regions.Regions\nimport com.amazonaws.services.dynamodbv2.document.DynamoDB\nimport com.amazonaws.services.dynamodbv2.document.Item\nimport com.amazonaws.services.lambda.runtime.Context\nimport com.tottokotkd.aws.gateway.core.*\nimport java.time.ZonedDateTime\nimport java.time.format.DateTimeFormatter\nimport kotlin.properties.Delegates\n\nclass SaveRequest {\n    lateinit var user: String\n    lateinit var url: String\n    var rate: Int by Delegates.notNull()\n    lateinit var timestamp: String\n}\n\nclass SaveHandler: DataHandler<SaveRequest, Any> {\n    override fun handleRequest(input: SaveRequest, context: Context): ResponseData<Any> {\n\n        val timestamp = try {\n            ZonedDateTime.parse(input.timestamp, DateTimeFormatter.ISO_DATE_TIME)\n        } catch (e: Exception) {\n            return ResponseData(mapOf(\"status\" to \"error\", \"desc\" to \"date time parsing failed.\"), StatusCode.BadRequest)\n        }\n\n        val dynamoDB = DynamoDB(Regions.US_EAST_1)\n        val t = dynamoDB.getTable(\"pages\")\n        val item = Item.fromMap(mapOf(\"user\" to input.user, \"url\" to input.url, \"rate\" to input.rate, \"epoch\" to timestamp.toEpochSecond(), \"timezone\" to timestamp.offset.totalSeconds))\n        val result = t.putItem(item)\n\n        return ResponseData(mapOf(\"status\" to \"success\", \"input\" to input))\n    }\n}\n```\n\n`SaveHandler`がリクエストハンドラーで、`SaveRequest`がリクエストに期待される内容ですね。言うまでもないか。\n\nAPI Gateway経由なのでJSONを渡されそうなものですが、実際はアマゾンがPOJOに突っ込んだうえで渡してくれます。Serverlessの設定として書くべきことも特になくて、本当にこのままLambdaにデプロイすれば面倒をみてくれます。DynamoDBもIAMさえ弄ればコードは1行で終わり。たったこれだけで (金さえ払えば) 無敵のスケーラビリティが手に入っちゃう。スゴイ！\n\nただしアマゾン様といえどもdata classのコンストラクタを使うような器用な芸当は当然やれないので、`SaveRequest`はプロパティ全てvarのクラスになっています。もっともここは`val hoge: String by Delegates.notNull()` の方がいいような気もするし、Web APIなんだから`String?`の方がかえってロジカルに書きやすいような気もするし、その辺りは僕もまだ深く考えてません。そこまでkotlinやAWSの挙動に詳しくないという事情もある。\n\nそれはともかく戻り値が`Any`になっていて許せん！という人もいると思いますが、これはmapOfで手軽に返したかったのです。データクラスとか指定すればちゃんと型安全で動きます (たぶん)。\n\nまあこの辺りは趣味の問題でもあり、生産性を上げるために工夫のしどころだとも思うので、`ResponseData`を使わず自前で実装する方がいいかもですね、ステータスコードは引数じゃなくて型に結びつけるとか。あるいはハンドラーの方にヘルパーをバシバシ生やすとか… その辺は今後ちょっと便利になったらいいかなあ。フォークしてPRで見せびらかしてくれる人とか出てきたら嬉しい。\n\n\n\nで、コードはもう特に書くことないので思い出をつらつらと。\n\n## API Gateway -> Lambda -> Error!\n\n`sls invoke -f hello` が動くぞ！やったー！などと隙を見せたエンジニアを強襲するAWS！\n\n> Malformed Lambda proxy response\n\nlambdaとしては呼べるけどcurlすると落ちる。\n\nServerless使って一番つらかったのはコレ。Kotlin + Serverless + API Gatewayなんて実際に使っているケースがほぼ見つからない上に、ちょっと古い記事だと「動きました！簡単」とか書いてあるコードが今はもう動かない。嘘だゾ、全然簡単じゃないゾ。\n\n\nということで頑張って検索して探したのがコレ。~~人柱サンキュー！~~\n\n{% blockquote kyl191 https://forums.aws.amazon.com/thread.jspa?threadID=239688 AWS Developer Forums: Lambda Proxy Expectations %}\nOk, I found some documentation which says it expects statusCode, body and headers in a dict.\n{% endblockquote %}\n\n何でこんな状態なのか、ちょっと意味が分からないんですけど、API Gateway (Lambda Proxy) から呼ばれるLambdaは**戻り値の型はどうでもいいしインターフェイスとかないけど、statusCode body headersという3つの値を持っていないと実行時エラーになる**という凡そJavaとは思われない動的な仕組みになっているみたいです。\n\nつまり、'sls invoke -f hello'の結果として\n\n```json\n{\"hage\": [\"ok\", \"cool\", \"amazing\"]}\n```\n\nみたいな結果が見えている場合はダメです。\n\nLambdaとしては動いているのですが、Gateway経由で呼びたいなら以下の内容でなければいけません。\n\n\n```json\n{\n    \"body\": {\n        \"hage\": [\"ok\", \"cool\", \"amazing\"]\n    },\n    \"headers\": {},\n    \"statusCode\": 400\n}\n```\n\nこのフォーマットを守らなければ、Lambda ProxyモードのAPI Gatewayは有効な結果として受け付けてくれないのです。理屈が分かってしまえば納得できますが、この落とし穴だけは本当にひどい罠だと思います。\n\n一旦Lambda側からJSONを出力した上で、それを改めてGateway側がチェックするんでしょうか？ 色々と想像してますが謎です。\n\nちなみにデータのJSON化はあっちがJacksonでやってくれるので、上記のようなプロパティを持つPOJOを投げればいいみたいです。kotlinならdata classですね。あと試していませんがmapでも大丈夫かなと。\n\nただまあ、そこを自由にしても特に利点がなさそうなうえ、誰の目にも明らかにバグの温床でしかありません。今回のラッパーでは3つのプロパティを明示的に要求するインターフェイスを作っておきました。そもそも本来こういう仕様になってなきゃJavaコードとしておかしいと思うんですけど、それはそれで公式SDKとしては狭すぎる感じもありますからね… まあ気持ちはわかります。クソですけど。\n\nLambdaプロキシ自体が割と新しい機能であることも考えると仕方ない、AWSはこういうものなのだ… と割り切りましょう。\n\n## 2つの型パラメータを持つジェネリッククラスでないとエラーになる\n\nもうエラーログが手元にないんですが、リクエストハンドラーとして型パラメータ1つのクラスを作ってみたら「型パラメータは2つないと困るんだよなァ！」みたいな激おこメッセージを飛ばしてきました。これまたちょっと意味が分からないんですけど、JSONをリクエストPOJOに変換するときに型パラメータを使おうとしているのかな？ とにかくダメなものはダメらしいです。\n\nそれにしたって型パラメータ2つじゃないとダメっておかしくねえか？設計どうなってんの？という気もしますが仕方ない、AWSはこういうものなのだ… と割り切りましょう。\n\n## Internal Server Error\nAPI Gatewayを通過して結果が戻ってくるまでの間にエラーが発生するとInternal Server Errorです。例えば「Lambda処理内でリクエストパラメータを参照したらnull例外で落ちた」とかいう場合、それはInternal Server Errorであり、Gatewayのデフォルト処理が走って超ダサいJSONを投げ返します。\n\nサーバー内部でエラーが発生するなら、API Gatewayの視点からは全てInternal Server Errorなのです。まあそりゃ当然の挙動なんですけど、それはAPIを書く側からするとBadRequestだし、そもそも勝手にダサいJSONを流されるのも困ります。\n\nということでつまり、ハンドラ全体をtryで囲わないと不安だし、リクエスト内容の処理もちゃんと書かないといけません。当たり前の話とはいえ若干ちょっと面倒そう…\n\nその辺りをうまく集約できるインターフェイスとか作らないと大変そうですね。まあもちろん「ステータスコードさえ取れるなら大丈夫、後はYAGNI」という考え方もあると思います。その辺りの線引きはちょっと難しそう。\n\n## ということで\n\nなんか動くものは作れそうだし頑張る。","slug":"1","published":1,"updated":"2016-12-11T06:08:33.000Z","_id":"ciwk8sffk0004dtc1hn9adtcl","comments":1,"layout":"post","photos":[],"link":"","content":"<p>タイトルの通りです。<a href=\"https://github.com/tottokotkd/GatewayHandler\" target=\"_blank\" rel=\"external\">githubに置いてある</a>し、<a href=\"https://bintray.com/bintray/jcenter?filterByPkgName=GatewayHandler\" target=\"_blank\" rel=\"external\">Bintray経由でjcenterにもある</a>ので使えます。この公開ルートは今回初めてやってみましたが、なかなか便利ですね。</p>\n<p>もちろん公開するだけならgithubページでもイケるんですけど、その作業が手間だったり、IntelliJくんがキャッシュ持つ段階でエラー吐いたり、面倒なのでBintrayです。今はあんまりそこを頑張りたくなかった、仕方なかった。</p>\n<p>githubの方に書いてあるんですけど、コードでいうとこんな感じ。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> hello</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.regions.Regions</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.dynamodbv2.document.DynamoDB</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.dynamodbv2.document.Item</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.lambda.runtime.Context</div><div class=\"line\"><span class=\"keyword\">import</span> com.tottokotkd.aws.gateway.core.*</div><div class=\"line\"><span class=\"keyword\">import</span> java.time.ZonedDateTime</div><div class=\"line\"><span class=\"keyword\">import</span> java.time.format.DateTimeFormatter</div><div class=\"line\"><span class=\"keyword\">import</span> kotlin.properties.Delegates</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveRequest</span> </span>&#123;</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> user: String</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> url: String</div><div class=\"line\">    <span class=\"keyword\">var</span> rate: <span class=\"built_in\">Int</span> <span class=\"keyword\">by</span> Delegates.notNull()</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> timestamp: String</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveHandler</span>: <span class=\"type\">DataHandler</span>&lt;<span class=\"type\">SaveRequest, Any</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">handleRequest</span><span class=\"params\">(input: <span class=\"type\">SaveRequest</span>, context: <span class=\"type\">Context</span>)</span></span>: ResponseData&lt;Any&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">val</span> timestamp = <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            ZonedDateTime.parse(input.timestamp, DateTimeFormatter.ISO_DATE_TIME)</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ResponseData(mapOf(<span class=\"string\">\"status\"</span> to <span class=\"string\">\"error\"</span>, <span class=\"string\">\"desc\"</span> to <span class=\"string\">\"date time parsing failed.\"</span>), StatusCode.BadRequest)</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">val</span> dynamoDB = DynamoDB(Regions.US_EAST_1)</div><div class=\"line\">        <span class=\"keyword\">val</span> t = dynamoDB.getTable(<span class=\"string\">\"pages\"</span>)</div><div class=\"line\">        <span class=\"keyword\">val</span> item = Item.fromMap(mapOf(<span class=\"string\">\"user\"</span> to input.user, <span class=\"string\">\"url\"</span> to input.url, <span class=\"string\">\"rate\"</span> to input.rate, <span class=\"string\">\"epoch\"</span> to timestamp.toEpochSecond(), <span class=\"string\">\"timezone\"</span> to timestamp.offset.totalSeconds))</div><div class=\"line\">        <span class=\"keyword\">val</span> result = t.putItem(item)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> ResponseData(mapOf(<span class=\"string\">\"status\"</span> to <span class=\"string\">\"success\"</span>, <span class=\"string\">\"input\"</span> to input))</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>SaveHandler</code>がリクエストハンドラーで、<code>SaveRequest</code>がリクエストに期待される内容ですね。言うまでもないか。</p>\n<p>API Gateway経由なのでJSONを渡されそうなものですが、実際はアマゾンがPOJOに突っ込んだうえで渡してくれます。Serverlessの設定として書くべきことも特になくて、本当にこのままLambdaにデプロイすれば面倒をみてくれます。DynamoDBもIAMさえ弄ればコードは1行で終わり。たったこれだけで (金さえ払えば) 無敵のスケーラビリティが手に入っちゃう。スゴイ！</p>\n<p>ただしアマゾン様といえどもdata classのコンストラクタを使うような器用な芸当は当然やれないので、<code>SaveRequest</code>はプロパティ全てvarのクラスになっています。もっともここは<code>val hoge: String by Delegates.notNull()</code> の方がいいような気もするし、Web APIなんだから<code>String?</code>の方がかえってロジカルに書きやすいような気もするし、その辺りは僕もまだ深く考えてません。そこまでkotlinやAWSの挙動に詳しくないという事情もある。</p>\n<p>それはともかく戻り値が<code>Any</code>になっていて許せん！という人もいると思いますが、これはmapOfで手軽に返したかったのです。データクラスとか指定すればちゃんと型安全で動きます (たぶん)。</p>\n<p>まあこの辺りは趣味の問題でもあり、生産性を上げるために工夫のしどころだとも思うので、<code>ResponseData</code>を使わず自前で実装する方がいいかもですね、ステータスコードは引数じゃなくて型に結びつけるとか。あるいはハンドラーの方にヘルパーをバシバシ生やすとか… その辺は今後ちょっと便利になったらいいかなあ。フォークしてPRで見せびらかしてくれる人とか出てきたら嬉しい。</p>\n<p>で、コードはもう特に書くことないので思い出をつらつらと。</p>\n<h2 id=\"API-Gateway-gt-Lambda-gt-Error\"><a href=\"#API-Gateway-gt-Lambda-gt-Error\" class=\"headerlink\" title=\"API Gateway -&gt; Lambda -&gt; Error!\"></a>API Gateway -&gt; Lambda -&gt; Error!</h2><p><code>sls invoke -f hello</code> が動くぞ！やったー！などと隙を見せたエンジニアを強襲するAWS！</p>\n<blockquote>\n<p>Malformed Lambda proxy response</p>\n</blockquote>\n<p>lambdaとしては呼べるけどcurlすると落ちる。</p>\n<p>Serverless使って一番つらかったのはコレ。Kotlin + Serverless + API Gatewayなんて実際に使っているケースがほぼ見つからない上に、ちょっと古い記事だと「動きました！簡単」とか書いてあるコードが今はもう動かない。嘘だゾ、全然簡単じゃないゾ。</p>\n<p>ということで頑張って検索して探したのがコレ。<del>人柱サンキュー！</del></p>\n<blockquote><p>Ok, I found some documentation which says it expects statusCode, body and headers in a dict.</p>\n<footer><strong>kyl191</strong><cite><a href=\"https://forums.aws.amazon.com/thread.jspa?threadID=239688\" target=\"_blank\" rel=\"external\">AWS Developer Forums: Lambda Proxy Expectations</a></cite></footer></blockquote>\n<p>何でこんな状態なのか、ちょっと意味が分からないんですけど、API Gateway (Lambda Proxy) から呼ばれるLambdaは<strong>戻り値の型はどうでもいいしインターフェイスとかないけど、statusCode body headersという3つの値を持っていないと実行時エラーになる</strong>という凡そJavaとは思われない動的な仕組みになっているみたいです。</p>\n<p>つまり、’sls invoke -f hello’の結果として</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;<span class=\"attr\">\"hage\"</span>: [<span class=\"string\">\"ok\"</span>, <span class=\"string\">\"cool\"</span>, <span class=\"string\">\"amazing\"</span>]&#125;</div></pre></td></tr></table></figure>\n<p>みたいな結果が見えている場合はダメです。</p>\n<p>Lambdaとしては動いているのですが、Gateway経由で呼びたいなら以下の内容でなければいけません。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"body\"</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">\"hage\"</span>: [<span class=\"string\">\"ok\"</span>, <span class=\"string\">\"cool\"</span>, <span class=\"string\">\"amazing\"</span>]</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"headers\"</span>: &#123;&#125;,</div><div class=\"line\">    <span class=\"attr\">\"statusCode\"</span>: <span class=\"number\">400</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>このフォーマットを守らなければ、Lambda ProxyモードのAPI Gatewayは有効な結果として受け付けてくれないのです。理屈が分かってしまえば納得できますが、この落とし穴だけは本当にひどい罠だと思います。</p>\n<p>一旦Lambda側からJSONを出力した上で、それを改めてGateway側がチェックするんでしょうか？ 色々と想像してますが謎です。</p>\n<p>ちなみにデータのJSON化はあっちがJacksonでやってくれるので、上記のようなプロパティを持つPOJOを投げればいいみたいです。kotlinならdata classですね。あと試していませんがmapでも大丈夫かなと。</p>\n<p>ただまあ、そこを自由にしても特に利点がなさそうなうえ、誰の目にも明らかにバグの温床でしかありません。今回のラッパーでは3つのプロパティを明示的に要求するインターフェイスを作っておきました。そもそも本来こういう仕様になってなきゃJavaコードとしておかしいと思うんですけど、それはそれで公式SDKとしては狭すぎる感じもありますからね… まあ気持ちはわかります。クソですけど。</p>\n<p>Lambdaプロキシ自体が割と新しい機能であることも考えると仕方ない、AWSはこういうものなのだ… と割り切りましょう。</p>\n<h2 id=\"2つの型パラメータを持つジェネリッククラスでないとエラーになる\"><a href=\"#2つの型パラメータを持つジェネリッククラスでないとエラーになる\" class=\"headerlink\" title=\"2つの型パラメータを持つジェネリッククラスでないとエラーになる\"></a>2つの型パラメータを持つジェネリッククラスでないとエラーになる</h2><p>もうエラーログが手元にないんですが、リクエストハンドラーとして型パラメータ1つのクラスを作ってみたら「型パラメータは2つないと困るんだよなァ！」みたいな激おこメッセージを飛ばしてきました。これまたちょっと意味が分からないんですけど、JSONをリクエストPOJOに変換するときに型パラメータを使おうとしているのかな？ とにかくダメなものはダメらしいです。</p>\n<p>それにしたって型パラメータ2つじゃないとダメっておかしくねえか？設計どうなってんの？という気もしますが仕方ない、AWSはこういうものなのだ… と割り切りましょう。</p>\n<h2 id=\"Internal-Server-Error\"><a href=\"#Internal-Server-Error\" class=\"headerlink\" title=\"Internal Server Error\"></a>Internal Server Error</h2><p>API Gatewayを通過して結果が戻ってくるまでの間にエラーが発生するとInternal Server Errorです。例えば「Lambda処理内でリクエストパラメータを参照したらnull例外で落ちた」とかいう場合、それはInternal Server Errorであり、Gatewayのデフォルト処理が走って超ダサいJSONを投げ返します。</p>\n<p>サーバー内部でエラーが発生するなら、API Gatewayの視点からは全てInternal Server Errorなのです。まあそりゃ当然の挙動なんですけど、それはAPIを書く側からするとBadRequestだし、そもそも勝手にダサいJSONを流されるのも困ります。</p>\n<p>ということでつまり、ハンドラ全体をtryで囲わないと不安だし、リクエスト内容の処理もちゃんと書かないといけません。当たり前の話とはいえ若干ちょっと面倒そう…</p>\n<p>その辺りをうまく集約できるインターフェイスとか作らないと大変そうですね。まあもちろん「ステータスコードさえ取れるなら大丈夫、後はYAGNI」という考え方もあると思います。その辺りの線引きはちょっと難しそう。</p>\n<h2 id=\"ということで\"><a href=\"#ということで\" class=\"headerlink\" title=\"ということで\"></a>ということで</h2><p>なんか動くものは作れそうだし頑張る。</p>\n","excerpt":"","more":"<p>タイトルの通りです。<a href=\"https://github.com/tottokotkd/GatewayHandler\">githubに置いてある</a>し、<a href=\"https://bintray.com/bintray/jcenter?filterByPkgName=GatewayHandler\">Bintray経由でjcenterにもある</a>ので使えます。この公開ルートは今回初めてやってみましたが、なかなか便利ですね。</p>\n<p>もちろん公開するだけならgithubページでもイケるんですけど、その作業が手間だったり、IntelliJくんがキャッシュ持つ段階でエラー吐いたり、面倒なのでBintrayです。今はあんまりそこを頑張りたくなかった、仕方なかった。</p>\n<p>githubの方に書いてあるんですけど、コードでいうとこんな感じ。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> hello</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.regions.Regions</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.dynamodbv2.document.DynamoDB</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.dynamodbv2.document.Item</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.lambda.runtime.Context</div><div class=\"line\"><span class=\"keyword\">import</span> com.tottokotkd.aws.gateway.core.*</div><div class=\"line\"><span class=\"keyword\">import</span> java.time.ZonedDateTime</div><div class=\"line\"><span class=\"keyword\">import</span> java.time.format.DateTimeFormatter</div><div class=\"line\"><span class=\"keyword\">import</span> kotlin.properties.Delegates</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveRequest</span> </span>&#123;</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> user: String</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> url: String</div><div class=\"line\">    <span class=\"keyword\">var</span> rate: <span class=\"built_in\">Int</span> <span class=\"keyword\">by</span> Delegates.notNull()</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> timestamp: String</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveHandler</span>: <span class=\"type\">DataHandler</span>&lt;<span class=\"type\">SaveRequest, Any</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">handleRequest</span><span class=\"params\">(input: <span class=\"type\">SaveRequest</span>, context: <span class=\"type\">Context</span>)</span></span>: ResponseData&lt;Any&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">val</span> timestamp = <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            ZonedDateTime.parse(input.timestamp, DateTimeFormatter.ISO_DATE_TIME)</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ResponseData(mapOf(<span class=\"string\">\"status\"</span> to <span class=\"string\">\"error\"</span>, <span class=\"string\">\"desc\"</span> to <span class=\"string\">\"date time parsing failed.\"</span>), StatusCode.BadRequest)</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">val</span> dynamoDB = DynamoDB(Regions.US_EAST_1)</div><div class=\"line\">        <span class=\"keyword\">val</span> t = dynamoDB.getTable(<span class=\"string\">\"pages\"</span>)</div><div class=\"line\">        <span class=\"keyword\">val</span> item = Item.fromMap(mapOf(<span class=\"string\">\"user\"</span> to input.user, <span class=\"string\">\"url\"</span> to input.url, <span class=\"string\">\"rate\"</span> to input.rate, <span class=\"string\">\"epoch\"</span> to timestamp.toEpochSecond(), <span class=\"string\">\"timezone\"</span> to timestamp.offset.totalSeconds))</div><div class=\"line\">        <span class=\"keyword\">val</span> result = t.putItem(item)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> ResponseData(mapOf(<span class=\"string\">\"status\"</span> to <span class=\"string\">\"success\"</span>, <span class=\"string\">\"input\"</span> to input))</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>SaveHandler</code>がリクエストハンドラーで、<code>SaveRequest</code>がリクエストに期待される内容ですね。言うまでもないか。</p>\n<p>API Gateway経由なのでJSONを渡されそうなものですが、実際はアマゾンがPOJOに突っ込んだうえで渡してくれます。Serverlessの設定として書くべきことも特になくて、本当にこのままLambdaにデプロイすれば面倒をみてくれます。DynamoDBもIAMさえ弄ればコードは1行で終わり。たったこれだけで (金さえ払えば) 無敵のスケーラビリティが手に入っちゃう。スゴイ！</p>\n<p>ただしアマゾン様といえどもdata classのコンストラクタを使うような器用な芸当は当然やれないので、<code>SaveRequest</code>はプロパティ全てvarのクラスになっています。もっともここは<code>val hoge: String by Delegates.notNull()</code> の方がいいような気もするし、Web APIなんだから<code>String?</code>の方がかえってロジカルに書きやすいような気もするし、その辺りは僕もまだ深く考えてません。そこまでkotlinやAWSの挙動に詳しくないという事情もある。</p>\n<p>それはともかく戻り値が<code>Any</code>になっていて許せん！という人もいると思いますが、これはmapOfで手軽に返したかったのです。データクラスとか指定すればちゃんと型安全で動きます (たぶん)。</p>\n<p>まあこの辺りは趣味の問題でもあり、生産性を上げるために工夫のしどころだとも思うので、<code>ResponseData</code>を使わず自前で実装する方がいいかもですね、ステータスコードは引数じゃなくて型に結びつけるとか。あるいはハンドラーの方にヘルパーをバシバシ生やすとか… その辺は今後ちょっと便利になったらいいかなあ。フォークしてPRで見せびらかしてくれる人とか出てきたら嬉しい。</p>\n<p>で、コードはもう特に書くことないので思い出をつらつらと。</p>\n<h2 id=\"API-Gateway-gt-Lambda-gt-Error\"><a href=\"#API-Gateway-gt-Lambda-gt-Error\" class=\"headerlink\" title=\"API Gateway -&gt; Lambda -&gt; Error!\"></a>API Gateway -&gt; Lambda -&gt; Error!</h2><p><code>sls invoke -f hello</code> が動くぞ！やったー！などと隙を見せたエンジニアを強襲するAWS！</p>\n<blockquote>\n<p>Malformed Lambda proxy response</p>\n</blockquote>\n<p>lambdaとしては呼べるけどcurlすると落ちる。</p>\n<p>Serverless使って一番つらかったのはコレ。Kotlin + Serverless + API Gatewayなんて実際に使っているケースがほぼ見つからない上に、ちょっと古い記事だと「動きました！簡単」とか書いてあるコードが今はもう動かない。嘘だゾ、全然簡単じゃないゾ。</p>\n<p>ということで頑張って検索して探したのがコレ。<del>人柱サンキュー！</del></p>\n<blockquote><p>Ok, I found some documentation which says it expects statusCode, body and headers in a dict.</p>\n<footer><strong>kyl191</strong><cite><a href=\"https://forums.aws.amazon.com/thread.jspa?threadID=239688\">AWS Developer Forums: Lambda Proxy Expectations</a></cite></footer></blockquote>\n<p>何でこんな状態なのか、ちょっと意味が分からないんですけど、API Gateway (Lambda Proxy) から呼ばれるLambdaは<strong>戻り値の型はどうでもいいしインターフェイスとかないけど、statusCode body headersという3つの値を持っていないと実行時エラーになる</strong>という凡そJavaとは思われない動的な仕組みになっているみたいです。</p>\n<p>つまり、’sls invoke -f hello’の結果として</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;<span class=\"attr\">\"hage\"</span>: [<span class=\"string\">\"ok\"</span>, <span class=\"string\">\"cool\"</span>, <span class=\"string\">\"amazing\"</span>]&#125;</div></pre></td></tr></table></figure>\n<p>みたいな結果が見えている場合はダメです。</p>\n<p>Lambdaとしては動いているのですが、Gateway経由で呼びたいなら以下の内容でなければいけません。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"body\"</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">\"hage\"</span>: [<span class=\"string\">\"ok\"</span>, <span class=\"string\">\"cool\"</span>, <span class=\"string\">\"amazing\"</span>]</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"headers\"</span>: &#123;&#125;,</div><div class=\"line\">    <span class=\"attr\">\"statusCode\"</span>: <span class=\"number\">400</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>このフォーマットを守らなければ、Lambda ProxyモードのAPI Gatewayは有効な結果として受け付けてくれないのです。理屈が分かってしまえば納得できますが、この落とし穴だけは本当にひどい罠だと思います。</p>\n<p>一旦Lambda側からJSONを出力した上で、それを改めてGateway側がチェックするんでしょうか？ 色々と想像してますが謎です。</p>\n<p>ちなみにデータのJSON化はあっちがJacksonでやってくれるので、上記のようなプロパティを持つPOJOを投げればいいみたいです。kotlinならdata classですね。あと試していませんがmapでも大丈夫かなと。</p>\n<p>ただまあ、そこを自由にしても特に利点がなさそうなうえ、誰の目にも明らかにバグの温床でしかありません。今回のラッパーでは3つのプロパティを明示的に要求するインターフェイスを作っておきました。そもそも本来こういう仕様になってなきゃJavaコードとしておかしいと思うんですけど、それはそれで公式SDKとしては狭すぎる感じもありますからね… まあ気持ちはわかります。クソですけど。</p>\n<p>Lambdaプロキシ自体が割と新しい機能であることも考えると仕方ない、AWSはこういうものなのだ… と割り切りましょう。</p>\n<h2 id=\"2つの型パラメータを持つジェネリッククラスでないとエラーになる\"><a href=\"#2つの型パラメータを持つジェネリッククラスでないとエラーになる\" class=\"headerlink\" title=\"2つの型パラメータを持つジェネリッククラスでないとエラーになる\"></a>2つの型パラメータを持つジェネリッククラスでないとエラーになる</h2><p>もうエラーログが手元にないんですが、リクエストハンドラーとして型パラメータ1つのクラスを作ってみたら「型パラメータは2つないと困るんだよなァ！」みたいな激おこメッセージを飛ばしてきました。これまたちょっと意味が分からないんですけど、JSONをリクエストPOJOに変換するときに型パラメータを使おうとしているのかな？ とにかくダメなものはダメらしいです。</p>\n<p>それにしたって型パラメータ2つじゃないとダメっておかしくねえか？設計どうなってんの？という気もしますが仕方ない、AWSはこういうものなのだ… と割り切りましょう。</p>\n<h2 id=\"Internal-Server-Error\"><a href=\"#Internal-Server-Error\" class=\"headerlink\" title=\"Internal Server Error\"></a>Internal Server Error</h2><p>API Gatewayを通過して結果が戻ってくるまでの間にエラーが発生するとInternal Server Errorです。例えば「Lambda処理内でリクエストパラメータを参照したらnull例外で落ちた」とかいう場合、それはInternal Server Errorであり、Gatewayのデフォルト処理が走って超ダサいJSONを投げ返します。</p>\n<p>サーバー内部でエラーが発生するなら、API Gatewayの視点からは全てInternal Server Errorなのです。まあそりゃ当然の挙動なんですけど、それはAPIを書く側からするとBadRequestだし、そもそも勝手にダサいJSONを流されるのも困ります。</p>\n<p>ということでつまり、ハンドラ全体をtryで囲わないと不安だし、リクエスト内容の処理もちゃんと書かないといけません。当たり前の話とはいえ若干ちょっと面倒そう…</p>\n<p>その辺りをうまく集約できるインターフェイスとか作らないと大変そうですね。まあもちろん「ステータスコードさえ取れるなら大丈夫、後はYAGNI」という考え方もあると思います。その辺りの線引きはちょっと難しそう。</p>\n<h2 id=\"ということで\"><a href=\"#ということで\" class=\"headerlink\" title=\"ということで\"></a>ということで</h2><p>なんか動くものは作れそうだし頑張る。</p>\n"},{"title":"swift buildで渡すオプションをいちいち書きたくないのでcmakeする","date":"2016-11-22T13:33:03.000Z","_content":"\nいまサーバーサイドSwiftが盛り上がっています。まだ派手に燃えてはいませんが、確実に火がついています。だいたいXamarin勉強会の翌日くらい燃えてます。\n\nそういう次第でswiftの話です。毎度毎度 `swift build -Xswiftc -I/usr/local/include/mysql -Xlinker -L/usr/local/lib\n` とか書きたくない人は幸せになれるかもしれないです。\n\n## CMakeFiles.txtを書くべし\n\nまずこういうやつ書いてください。ビルドコマンドのオプションを適宜いい感じにしましょう。\n\n```cmake\ncmake_minimum_required(VERSION 3.6)\nproject(MariaDbTaler)\n\nset(SOURCE_FILES\n        Sources/MariaDbDriver.swift\n        Package.swift)\n\nset(SWIFT_COMMAND\n        swift build\n        -Xlinker -L/usr/local/lib\n        -Xcc -I/usr/local/include\n        -Xswiftc -lmysqlclient)\n\nadd_custom_target(MariaDbTaler\n        COMMAND ${SWIFT_COMMAND}\n        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}\n        SOURCES ${SOURCE_FILES})\n```\n\nなお試してませんが明らかに`SOURCE_FILES`は書かなくてよい気がいたします。\n\n## `cmake .`すべし\n\n[人類なら`out-of-source`ビルドしなさい](http://qiita.com/osamu0329/items/7de2b190df3cfb4ad0ca)という話もありますが、最初はまあいいです。1回実行してゴミファイルが大量に出来てから後悔しても遅くないです。\n\n## `make XXXXXX` すべし\n\n上の例だと`make MariaDbTaler`ですね。プロジェクト名を渡してやります。そうするとあらかじめ設定してあるコマンドが走るのです。\n\n## 別にCMakeいらなくね？\n\nいらないです。CMake経由しても特にいいことないしシェルスクリプト書けばいいじゃん。なんだよこれ！\n\nところが、みんな大好きJetBrains謹製IDEであるCLionくんが \"[CLion relies on CMake project model, so you need to start a CMake project for Swift](https://blog.jetbrains.com/clion/2015/12/swift-plugin-for-clion/)\" と宣うているのです。正直まだまだCLionのSwiftプラグインはショボくて辛い感じなのですが、CLionを使うならCMakeFiles.txtは嫌でも書かなきゃいけません。そこで一括して書けると考えれば、まあちょっとだけ便利です。\n\n## 余談: -Xswiftc is 何\n\n`swift --help`ってなんか使いにくい気がしてならないんですよね。ヘルプ叩いたらサブコマンドの一覧も出してほしいし… `swift package update`の存在とか分かりにくすぎるし… しかしまあそれはいいです。\n\n`-Xswiftc`のことは`swift build --help`すれば分かります。\n\n```swift\n$ swift build --help\n\nOVERVIEW: Build sources into binary products\n\nUSAGE: swift build [mode] [options]\n\nMODES:\n  -c, --configuration <value>   Build with configuration (debug|release) [default: debug]\n  --clean [<mode>]              Delete artifacts (build|dist) [default: build]\n\nOPTIONS:\n  -C, --chdir <path>       Change working directory before any other operation\n  --build-path <path>      Specify build/cache directory [default: ./.build]\n  --color <mode>           Specify color mode (auto|always|never) [default: auto]\n  -v, --verbose            Increase verbosity of informational output\n  -Xcc <flag>              Pass flag through to all C compiler invocations\n  -Xlinker <flag>          Pass flag through to all linker invocations\n  -Xswiftc <flag>          Pass flag through to all Swift compiler invocations\n\nNOTE: Use `swift package` to perform other functions on packages\n```\n\n`-Xswiftc`は分かったけど`-I/usr/local/include/mysql`が分からないんですけど！という人がいると困るので`swift --help | grep -e -I`します(全文は長い)。\n\n```swift\n$ swift --help | grep -e -I\n\n  -I <value>             Add directory to the import search path\n```\n\ngccでよく見かける愉快な仲間たちですね。Xcodeを使っていると普段全く意識しないと思いますが、-Iは「ヘッダーファイルをどこで探すか」を指定するオプションです。Xcodeのビルド設定にも`header search paths`とかいう項目がありますよね。アレですアレ。\n\nこれはつまり古代C言語の領域に突入しているわけです。`swift build`の挙動がよく分からないという人はC++あたりのコンパイラ・リンカの解説記事を読むといいかもしれないです。\n\n決してコンパイラーではありません、コンパイラです。","source":"_posts/20161202 swift buildで渡すオプションをいちいち書きたくないのでcmakeする.md","raw":"---\ntitle: swift buildで渡すオプションをいちいち書きたくないのでcmakeする\ndate: 2016-11-22 22:33:03\npermalink: 1\ntags:\n - Swift\n - CLion\n - CMake\n---\n\nいまサーバーサイドSwiftが盛り上がっています。まだ派手に燃えてはいませんが、確実に火がついています。だいたいXamarin勉強会の翌日くらい燃えてます。\n\nそういう次第でswiftの話です。毎度毎度 `swift build -Xswiftc -I/usr/local/include/mysql -Xlinker -L/usr/local/lib\n` とか書きたくない人は幸せになれるかもしれないです。\n\n## CMakeFiles.txtを書くべし\n\nまずこういうやつ書いてください。ビルドコマンドのオプションを適宜いい感じにしましょう。\n\n```cmake\ncmake_minimum_required(VERSION 3.6)\nproject(MariaDbTaler)\n\nset(SOURCE_FILES\n        Sources/MariaDbDriver.swift\n        Package.swift)\n\nset(SWIFT_COMMAND\n        swift build\n        -Xlinker -L/usr/local/lib\n        -Xcc -I/usr/local/include\n        -Xswiftc -lmysqlclient)\n\nadd_custom_target(MariaDbTaler\n        COMMAND ${SWIFT_COMMAND}\n        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}\n        SOURCES ${SOURCE_FILES})\n```\n\nなお試してませんが明らかに`SOURCE_FILES`は書かなくてよい気がいたします。\n\n## `cmake .`すべし\n\n[人類なら`out-of-source`ビルドしなさい](http://qiita.com/osamu0329/items/7de2b190df3cfb4ad0ca)という話もありますが、最初はまあいいです。1回実行してゴミファイルが大量に出来てから後悔しても遅くないです。\n\n## `make XXXXXX` すべし\n\n上の例だと`make MariaDbTaler`ですね。プロジェクト名を渡してやります。そうするとあらかじめ設定してあるコマンドが走るのです。\n\n## 別にCMakeいらなくね？\n\nいらないです。CMake経由しても特にいいことないしシェルスクリプト書けばいいじゃん。なんだよこれ！\n\nところが、みんな大好きJetBrains謹製IDEであるCLionくんが \"[CLion relies on CMake project model, so you need to start a CMake project for Swift](https://blog.jetbrains.com/clion/2015/12/swift-plugin-for-clion/)\" と宣うているのです。正直まだまだCLionのSwiftプラグインはショボくて辛い感じなのですが、CLionを使うならCMakeFiles.txtは嫌でも書かなきゃいけません。そこで一括して書けると考えれば、まあちょっとだけ便利です。\n\n## 余談: -Xswiftc is 何\n\n`swift --help`ってなんか使いにくい気がしてならないんですよね。ヘルプ叩いたらサブコマンドの一覧も出してほしいし… `swift package update`の存在とか分かりにくすぎるし… しかしまあそれはいいです。\n\n`-Xswiftc`のことは`swift build --help`すれば分かります。\n\n```swift\n$ swift build --help\n\nOVERVIEW: Build sources into binary products\n\nUSAGE: swift build [mode] [options]\n\nMODES:\n  -c, --configuration <value>   Build with configuration (debug|release) [default: debug]\n  --clean [<mode>]              Delete artifacts (build|dist) [default: build]\n\nOPTIONS:\n  -C, --chdir <path>       Change working directory before any other operation\n  --build-path <path>      Specify build/cache directory [default: ./.build]\n  --color <mode>           Specify color mode (auto|always|never) [default: auto]\n  -v, --verbose            Increase verbosity of informational output\n  -Xcc <flag>              Pass flag through to all C compiler invocations\n  -Xlinker <flag>          Pass flag through to all linker invocations\n  -Xswiftc <flag>          Pass flag through to all Swift compiler invocations\n\nNOTE: Use `swift package` to perform other functions on packages\n```\n\n`-Xswiftc`は分かったけど`-I/usr/local/include/mysql`が分からないんですけど！という人がいると困るので`swift --help | grep -e -I`します(全文は長い)。\n\n```swift\n$ swift --help | grep -e -I\n\n  -I <value>             Add directory to the import search path\n```\n\ngccでよく見かける愉快な仲間たちですね。Xcodeを使っていると普段全く意識しないと思いますが、-Iは「ヘッダーファイルをどこで探すか」を指定するオプションです。Xcodeのビルド設定にも`header search paths`とかいう項目がありますよね。アレですアレ。\n\nこれはつまり古代C言語の領域に突入しているわけです。`swift build`の挙動がよく分からないという人はC++あたりのコンパイラ・リンカの解説記事を読むといいかもしれないです。\n\n決してコンパイラーではありません、コンパイラです。","slug":"1","published":1,"updated":"2016-12-02T16:04:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwk8sffl0005dtc190ysrg7o","content":"<p>いまサーバーサイドSwiftが盛り上がっています。まだ派手に燃えてはいませんが、確実に火がついています。だいたいXamarin勉強会の翌日くらい燃えてます。</p>\n<p>そういう次第でswiftの話です。毎度毎度 <code>swift build -Xswiftc -I/usr/local/include/mysql -Xlinker -L/usr/local/lib</code> とか書きたくない人は幸せになれるかもしれないです。</p>\n<h2 id=\"CMakeFiles-txtを書くべし\"><a href=\"#CMakeFiles-txtを書くべし\" class=\"headerlink\" title=\"CMakeFiles.txtを書くべし\"></a>CMakeFiles.txtを書くべし</h2><p>まずこういうやつ書いてください。ビルドコマンドのオプションを適宜いい感じにしましょう。</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">3.6</span>)</div><div class=\"line\"><span class=\"keyword\">project</span>(MariaDbTaler)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">set</span>(SOURCE_FILES</div><div class=\"line\">        Sources/MariaDbDriver.swift</div><div class=\"line\">        Package.swift)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">set</span>(SWIFT_COMMAND</div><div class=\"line\">        swift build</div><div class=\"line\">        -Xlinker -L/usr/local/lib</div><div class=\"line\">        -Xcc -I/usr/local/<span class=\"keyword\">include</span></div><div class=\"line\">        -Xswiftc -lmysqlclient)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">add_custom_target</span>(MariaDbTaler</div><div class=\"line\">        COMMAND <span class=\"variable\">$&#123;SWIFT_COMMAND&#125;</span></div><div class=\"line\">        WORKING_DIRECTORY <span class=\"variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span></div><div class=\"line\">        SOURCES <span class=\"variable\">$&#123;SOURCE_FILES&#125;</span>)</div></pre></td></tr></table></figure>\n<p>なお試してませんが明らかに<code>SOURCE_FILES</code>は書かなくてよい気がいたします。</p>\n<h2 id=\"cmake-すべし\"><a href=\"#cmake-すべし\" class=\"headerlink\" title=\"cmake .すべし\"></a><code>cmake .</code>すべし</h2><p><a href=\"http://qiita.com/osamu0329/items/7de2b190df3cfb4ad0ca\" target=\"_blank\" rel=\"external\">人類なら<code>out-of-source</code>ビルドしなさい</a>という話もありますが、最初はまあいいです。1回実行してゴミファイルが大量に出来てから後悔しても遅くないです。</p>\n<h2 id=\"make-XXXXXX-すべし\"><a href=\"#make-XXXXXX-すべし\" class=\"headerlink\" title=\"make XXXXXX すべし\"></a><code>make XXXXXX</code> すべし</h2><p>上の例だと<code>make MariaDbTaler</code>ですね。プロジェクト名を渡してやります。そうするとあらかじめ設定してあるコマンドが走るのです。</p>\n<h2 id=\"別にCMakeいらなくね？\"><a href=\"#別にCMakeいらなくね？\" class=\"headerlink\" title=\"別にCMakeいらなくね？\"></a>別にCMakeいらなくね？</h2><p>いらないです。CMake経由しても特にいいことないしシェルスクリプト書けばいいじゃん。なんだよこれ！</p>\n<p>ところが、みんな大好きJetBrains謹製IDEであるCLionくんが “<a href=\"https://blog.jetbrains.com/clion/2015/12/swift-plugin-for-clion/\" target=\"_blank\" rel=\"external\">CLion relies on CMake project model, so you need to start a CMake project for Swift</a>“ と宣うているのです。正直まだまだCLionのSwiftプラグインはショボくて辛い感じなのですが、CLionを使うならCMakeFiles.txtは嫌でも書かなきゃいけません。そこで一括して書けると考えれば、まあちょっとだけ便利です。</p>\n<h2 id=\"余談-Xswiftc-is-何\"><a href=\"#余談-Xswiftc-is-何\" class=\"headerlink\" title=\"余談: -Xswiftc is 何\"></a>余談: -Xswiftc is 何</h2><p><code>swift --help</code>ってなんか使いにくい気がしてならないんですよね。ヘルプ叩いたらサブコマンドの一覧も出してほしいし… <code>swift package update</code>の存在とか分かりにくすぎるし… しかしまあそれはいいです。</p>\n<p><code>-Xswiftc</code>のことは<code>swift build --help</code>すれば分かります。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ swift build --help</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">OVERVIEW</span>: <span class=\"type\">Build</span> sources into binary products</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">USAGE</span>: swift build [mode] [options]</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">MODES</span>:</div><div class=\"line\">  -<span class=\"built_in\">c</span>, --configuration &lt;value&gt;   <span class=\"type\">Build</span> with configuration (debug|release) [<span class=\"keyword\">default</span>: debug]</div><div class=\"line\">  --clean [&lt;mode&gt;]              <span class=\"type\">Delete</span> artifacts (build|dist) [<span class=\"keyword\">default</span>: build]</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">OPTIONS</span>:</div><div class=\"line\">  -<span class=\"type\">C</span>, --chdir &lt;path&gt;       <span class=\"type\">Change</span> working directory before any other operation</div><div class=\"line\">  --build-path &lt;path&gt;      <span class=\"type\">Specify</span> build/cache directory [<span class=\"keyword\">default</span>: ./.build]</div><div class=\"line\">  --color &lt;mode&gt;           <span class=\"type\">Specify</span> color mode (auto|always|never) [<span class=\"keyword\">default</span>: auto]</div><div class=\"line\">  -v, --verbose            <span class=\"type\">Increase</span> verbosity of informational output</div><div class=\"line\">  -<span class=\"type\">Xcc</span> &lt;flag&gt;              <span class=\"type\">Pass</span> flag through to all <span class=\"type\">C</span> compiler invocations</div><div class=\"line\">  -<span class=\"type\">Xlinker</span> &lt;flag&gt;          <span class=\"type\">Pass</span> flag through to all linker invocations</div><div class=\"line\">  -<span class=\"type\">Xswiftc</span> &lt;flag&gt;          <span class=\"type\">Pass</span> flag through to all <span class=\"type\">Swift</span> compiler invocations</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">NOTE</span>: <span class=\"type\">Use</span> `swift package` to perform other functions on packages</div></pre></td></tr></table></figure>\n<p><code>-Xswiftc</code>は分かったけど<code>-I/usr/local/include/mysql</code>が分からないんですけど！という人がいると困るので<code>swift --help | grep -e -I</code>します(全文は長い)。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ swift --help | grep -e -<span class=\"type\">I</span></div><div class=\"line\"></div><div class=\"line\">  -<span class=\"type\">I</span> &lt;value&gt;             <span class=\"type\">Add</span> directory to the <span class=\"keyword\">import</span> search path</div></pre></td></tr></table></figure>\n<p>gccでよく見かける愉快な仲間たちですね。Xcodeを使っていると普段全く意識しないと思いますが、-Iは「ヘッダーファイルをどこで探すか」を指定するオプションです。Xcodeのビルド設定にも<code>header search paths</code>とかいう項目がありますよね。アレですアレ。</p>\n<p>これはつまり古代C言語の領域に突入しているわけです。<code>swift build</code>の挙動がよく分からないという人はC++あたりのコンパイラ・リンカの解説記事を読むといいかもしれないです。</p>\n<p>決してコンパイラーではありません、コンパイラです。</p>\n","excerpt":"","more":"<p>いまサーバーサイドSwiftが盛り上がっています。まだ派手に燃えてはいませんが、確実に火がついています。だいたいXamarin勉強会の翌日くらい燃えてます。</p>\n<p>そういう次第でswiftの話です。毎度毎度 <code>swift build -Xswiftc -I/usr/local/include/mysql -Xlinker -L/usr/local/lib</code> とか書きたくない人は幸せになれるかもしれないです。</p>\n<h2 id=\"CMakeFiles-txtを書くべし\"><a href=\"#CMakeFiles-txtを書くべし\" class=\"headerlink\" title=\"CMakeFiles.txtを書くべし\"></a>CMakeFiles.txtを書くべし</h2><p>まずこういうやつ書いてください。ビルドコマンドのオプションを適宜いい感じにしましょう。</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">3.6</span>)</div><div class=\"line\"><span class=\"keyword\">project</span>(MariaDbTaler)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">set</span>(SOURCE_FILES</div><div class=\"line\">        Sources/MariaDbDriver.swift</div><div class=\"line\">        Package.swift)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">set</span>(SWIFT_COMMAND</div><div class=\"line\">        swift build</div><div class=\"line\">        -Xlinker -L/usr/local/lib</div><div class=\"line\">        -Xcc -I/usr/local/<span class=\"keyword\">include</span></div><div class=\"line\">        -Xswiftc -lmysqlclient)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">add_custom_target</span>(MariaDbTaler</div><div class=\"line\">        COMMAND <span class=\"variable\">$&#123;SWIFT_COMMAND&#125;</span></div><div class=\"line\">        WORKING_DIRECTORY <span class=\"variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span></div><div class=\"line\">        SOURCES <span class=\"variable\">$&#123;SOURCE_FILES&#125;</span>)</div></pre></td></tr></table></figure>\n<p>なお試してませんが明らかに<code>SOURCE_FILES</code>は書かなくてよい気がいたします。</p>\n<h2 id=\"cmake-すべし\"><a href=\"#cmake-すべし\" class=\"headerlink\" title=\"cmake .すべし\"></a><code>cmake .</code>すべし</h2><p><a href=\"http://qiita.com/osamu0329/items/7de2b190df3cfb4ad0ca\">人類なら<code>out-of-source</code>ビルドしなさい</a>という話もありますが、最初はまあいいです。1回実行してゴミファイルが大量に出来てから後悔しても遅くないです。</p>\n<h2 id=\"make-XXXXXX-すべし\"><a href=\"#make-XXXXXX-すべし\" class=\"headerlink\" title=\"make XXXXXX すべし\"></a><code>make XXXXXX</code> すべし</h2><p>上の例だと<code>make MariaDbTaler</code>ですね。プロジェクト名を渡してやります。そうするとあらかじめ設定してあるコマンドが走るのです。</p>\n<h2 id=\"別にCMakeいらなくね？\"><a href=\"#別にCMakeいらなくね？\" class=\"headerlink\" title=\"別にCMakeいらなくね？\"></a>別にCMakeいらなくね？</h2><p>いらないです。CMake経由しても特にいいことないしシェルスクリプト書けばいいじゃん。なんだよこれ！</p>\n<p>ところが、みんな大好きJetBrains謹製IDEであるCLionくんが “<a href=\"https://blog.jetbrains.com/clion/2015/12/swift-plugin-for-clion/\">CLion relies on CMake project model, so you need to start a CMake project for Swift</a>“ と宣うているのです。正直まだまだCLionのSwiftプラグインはショボくて辛い感じなのですが、CLionを使うならCMakeFiles.txtは嫌でも書かなきゃいけません。そこで一括して書けると考えれば、まあちょっとだけ便利です。</p>\n<h2 id=\"余談-Xswiftc-is-何\"><a href=\"#余談-Xswiftc-is-何\" class=\"headerlink\" title=\"余談: -Xswiftc is 何\"></a>余談: -Xswiftc is 何</h2><p><code>swift --help</code>ってなんか使いにくい気がしてならないんですよね。ヘルプ叩いたらサブコマンドの一覧も出してほしいし… <code>swift package update</code>の存在とか分かりにくすぎるし… しかしまあそれはいいです。</p>\n<p><code>-Xswiftc</code>のことは<code>swift build --help</code>すれば分かります。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ swift build --help</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">OVERVIEW</span>: <span class=\"type\">Build</span> sources into binary products</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">USAGE</span>: swift build [mode] [options]</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">MODES</span>:</div><div class=\"line\">  -<span class=\"built_in\">c</span>, --configuration &lt;value&gt;   <span class=\"type\">Build</span> with configuration (debug|release) [<span class=\"keyword\">default</span>: debug]</div><div class=\"line\">  --clean [&lt;mode&gt;]              <span class=\"type\">Delete</span> artifacts (build|dist) [<span class=\"keyword\">default</span>: build]</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">OPTIONS</span>:</div><div class=\"line\">  -<span class=\"type\">C</span>, --chdir &lt;path&gt;       <span class=\"type\">Change</span> working directory before any other operation</div><div class=\"line\">  --build-path &lt;path&gt;      <span class=\"type\">Specify</span> build/cache directory [<span class=\"keyword\">default</span>: ./.build]</div><div class=\"line\">  --color &lt;mode&gt;           <span class=\"type\">Specify</span> color mode (auto|always|never) [<span class=\"keyword\">default</span>: auto]</div><div class=\"line\">  -v, --verbose            <span class=\"type\">Increase</span> verbosity of informational output</div><div class=\"line\">  -<span class=\"type\">Xcc</span> &lt;flag&gt;              <span class=\"type\">Pass</span> flag through to all <span class=\"type\">C</span> compiler invocations</div><div class=\"line\">  -<span class=\"type\">Xlinker</span> &lt;flag&gt;          <span class=\"type\">Pass</span> flag through to all linker invocations</div><div class=\"line\">  -<span class=\"type\">Xswiftc</span> &lt;flag&gt;          <span class=\"type\">Pass</span> flag through to all <span class=\"type\">Swift</span> compiler invocations</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">NOTE</span>: <span class=\"type\">Use</span> `swift package` to perform other functions on packages</div></pre></td></tr></table></figure>\n<p><code>-Xswiftc</code>は分かったけど<code>-I/usr/local/include/mysql</code>が分からないんですけど！という人がいると困るので<code>swift --help | grep -e -I</code>します(全文は長い)。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ swift --help | grep -e -<span class=\"type\">I</span></div><div class=\"line\"></div><div class=\"line\">  -<span class=\"type\">I</span> &lt;value&gt;             <span class=\"type\">Add</span> directory to the <span class=\"keyword\">import</span> search path</div></pre></td></tr></table></figure>\n<p>gccでよく見かける愉快な仲間たちですね。Xcodeを使っていると普段全く意識しないと思いますが、-Iは「ヘッダーファイルをどこで探すか」を指定するオプションです。Xcodeのビルド設定にも<code>header search paths</code>とかいう項目がありますよね。アレですアレ。</p>\n<p>これはつまり古代C言語の領域に突入しているわけです。<code>swift build</code>の挙動がよく分からないという人はC++あたりのコンパイラ・リンカの解説記事を読むといいかもしれないです。</p>\n<p>決してコンパイラーではありません、コンパイラです。</p>\n"},{"title":"Kotlin + AWS Lambda + API GatewayでServerlessできちゃうラッパー公開したのでDynamoDBとか使っちゃう","date":"2016-12-11T03:36:08.000Z","_content":"\nタイトルの通りです。[githubに置いてある](https://github.com/tottokotkd/GatewayHandler)し、[Bintray経由でjcenterにもある](https://bintray.com/bintray/jcenter?filterByPkgName=GatewayHandler)ので使えます。この公開ルートは今回初めてやってみましたが、なかなか便利ですね。\n\nもちろん公開するだけならgithubページでもイケるんですけど、その作業が手間だったり、IntelliJくんがキャッシュ持つ段階でエラー吐いたり、面倒なのでBintrayです。今はあんまりそこを頑張りたくなかった、仕方なかった。\n\ngithubの方に書いてあるんですけど、コードでいうとこんな感じ。\n\n```kotlin\npackage hello\n\nimport com.amazonaws.regions.Regions\nimport com.amazonaws.services.dynamodbv2.document.DynamoDB\nimport com.amazonaws.services.dynamodbv2.document.Item\nimport com.amazonaws.services.lambda.runtime.Context\nimport com.tottokotkd.aws.gateway.core.*\nimport java.time.ZonedDateTime\nimport java.time.format.DateTimeFormatter\nimport kotlin.properties.Delegates\n\nclass SaveRequest {\n    lateinit var user: String\n    lateinit var url: String\n    var rate: Int by Delegates.notNull()\n    lateinit var timestamp: String\n}\n\nclass SaveHandler: DataHandler<SaveRequest, Any> {\n    override fun handleRequest(input: SaveRequest, context: Context): ResponseData<Any> {\n\n        val timestamp = try {\n            ZonedDateTime.parse(input.timestamp, DateTimeFormatter.ISO_DATE_TIME)\n        } catch (e: Exception) {\n            return ResponseData(mapOf(\"status\" to \"error\", \"desc\" to \"date time parsing failed.\"), StatusCode.BadRequest)\n        }\n\n        val dynamoDB = DynamoDB(Regions.US_EAST_1)\n        val t = dynamoDB.getTable(\"pages\")\n        val item = Item.fromMap(mapOf(\"user\" to input.user, \"url\" to input.url, \"rate\" to input.rate, \"epoch\" to timestamp.toEpochSecond(), \"timezone\" to timestamp.offset.totalSeconds))\n        val result = t.putItem(item)\n\n        return ResponseData(mapOf(\"status\" to \"success\", \"input\" to input))\n    }\n}\n```\n\n`SaveHandler`がリクエストハンドラーで、`SaveRequest`がリクエストに期待される内容ですね。言うまでもないか。\n\nAPI Gateway経由なのでJSONを渡されそうなものですが、実際はアマゾンがPOJOに突っ込んだうえで渡してくれます。Serverlessの設定として書くべきことも特になくて、本当にこのままLambdaにデプロイすれば面倒をみてくれます。DynamoDBもIAMさえ弄ればコードは1行で終わり。たったこれだけで (金さえ払えば) 無敵のスケーラビリティが手に入っちゃう。スゴイ！\n\nただしアマゾン様といえどもdata classのコンストラクタを使うような器用な芸当は当然やれないので、`SaveRequest`はプロパティ全てvarのクラスになっています。もっともここは`val hoge: String by Delegates.notNull()` の方がいいような気もするし、Web APIなんだから`String?`の方がかえってロジカルに書きやすいような気もするし、その辺りは僕もまだ深く考えてません。そこまでkotlinやAWSの挙動に詳しくないという事情もある。\n\nそれはともかく戻り値が`Any`になっていて許せん！という人もいると思いますが、これはmapOfで手軽に返したかったのです。データクラスとか指定すればちゃんと型安全で動きます (たぶん)。\n\nまあこの辺りは趣味の問題でもあり、生産性を上げるために工夫のしどころだとも思うので、`ResponseData`を使わず自前で実装する方がいいかもですね、ステータスコードは引数じゃなくて型に結びつけるとか。あるいはハンドラーの方にヘルパーをバシバシ生やすとか… その辺は今後ちょっと便利になったらいいかなあ。フォークしてPRで見せびらかしてくれる人とか出てきたら嬉しい。\n\n\n\nで、コードはもう特に書くことないので思い出をつらつらと。\n\n## API Gateway -> Lambda -> Error!\n\n`sls invoke -f hello` が動くぞ！やったー！などと隙を見せたエンジニアを強襲するAWS！\n\n> Malformed Lambda proxy response\n\nlambdaとしては呼べるけどcurlすると落ちる。\n\nServerless使って一番つらかったのはコレ。Kotlin + Serverless + API Gatewayなんて実際に使っているケースがほぼ見つからない上に、ちょっと古い記事だと「動きました！簡単」とか書いてあるコードが今はもう動かない。嘘だゾ、全然簡単じゃないゾ。\n\n\nということで頑張って検索して探したのがコレ。~~人柱サンキュー！~~\n\n{% blockquote kyl191 https://forums.aws.amazon.com/thread.jspa?threadID=239688 AWS Developer Forums: Lambda Proxy Expectations %}\nOk, I found some documentation which says it expects statusCode, body and headers in a dict.\n{% endblockquote %}\n\n何でこんな状態なのか、ちょっと意味が分からないんですけど、API Gateway (Lambda Proxy) から呼ばれるLambdaは**戻り値の型はどうでもいいしインターフェイスとかないけど、statusCode body headersという3つの値を持っていないと実行時エラーになる**という凡そJavaとは思われない動的な仕組みになっているみたいです。\n\nつまり、'sls invoke -f hello'の結果として\n\n```json\n{\"hage\": [\"ok\", \"cool\", \"amazing\"]}\n```\n\nみたいな結果が見えている場合はダメです。\n\nLambdaとしては動いているのですが、Gateway経由で呼びたいなら以下の内容でなければいけません。\n\n\n```json\n{\n    \"body\": {\n        \"hage\": [\"ok\", \"cool\", \"amazing\"]\n    },\n    \"headers\": {},\n    \"statusCode\": 400\n}\n```\n\nこのフォーマットを守らなければ、Lambda ProxyモードのAPI Gatewayは有効な結果として受け付けてくれないのです。理屈が分かってしまえば納得できますが、この落とし穴だけは本当にひどい罠だと思います。\n\n一旦Lambda側からJSONを出力した上で、それを改めてGateway側がチェックするんでしょうか？ 色々と想像してますが謎です。\n\nちなみにデータのJSON化はあっちがJacksonでやってくれるので、上記のようなプロパティを持つPOJOを投げればいいみたいです。kotlinならdata classですね。あと試していませんがmapでも大丈夫かなと。\n\nただまあ、そこを自由にしても特に利点がなさそうなうえ、誰の目にも明らかにバグの温床でしかありません。今回のラッパーでは3つのプロパティを明示的に要求するインターフェイスを作っておきました。そもそも本来こういう仕様になってなきゃJavaコードとしておかしいと思うんですけど、それはそれで公式SDKとしては狭すぎる感じもありますからね… まあ気持ちはわかります。クソですけど。\n\nLambdaプロキシ自体が割と新しい機能であることも考えると仕方ない、AWSはこういうものなのだ… と割り切りましょう。\n\n## 2つの型パラメータを持つジェネリッククラスでないとエラーになる\n\nもうエラーログが手元にないんですが、リクエストハンドラーとして型パラメータ1つのクラスを作ってみたら「型パラメータは2つないと困るんだよなァ！」みたいな激おこメッセージを飛ばしてきました。これまたちょっと意味が分からないんですけど、JSONをリクエストPOJOに変換するときに型パラメータを使おうとしているのかな？ とにかくダメなものはダメらしいです。\n\nそれにしたって型パラメータ2つじゃないとダメっておかしくねえか？設計どうなってんの？という気もしますが仕方ない、AWSはこういうものなのだ… と割り切りましょう。\n\n## Internal Server Error\nAPI Gatewayを通過して結果が戻ってくるまでの間にエラーが発生するとInternal Server Errorです。例えば「Lambda処理内でリクエストパラメータを参照したらnull例外で落ちた」とかいう場合、それはInternal Server Errorであり、Gatewayのデフォルト処理が走って超ダサいJSONを投げ返します。\n\nサーバー内部でエラーが発生するなら、API Gatewayの視点からは全てInternal Server Errorなのです。まあそりゃ当然の挙動なんですけど、それはAPIを書く側からするとBadRequestだし、そもそも勝手にダサいJSONを流されるのも困ります。\n\nということでつまり、ハンドラ全体をtryで囲わないと不安だし、リクエスト内容の処理もちゃんと書かないといけません。当たり前の話とはいえ若干ちょっと面倒そう…\n\nその辺りをうまく集約できるインターフェイスとか作らないと大変そうですね。まあもちろん「ステータスコードさえ取れるなら大丈夫、後はYAGNI」という考え方もあると思います。その辺りの線引きはちょっと難しそう。\n\n## ということで\n\nなんか動くものは作れそうだし頑張る。","source":"_posts/20161211 Kotlin + AWS Lambda + API GatewayでServerlessできちゃうラッパー公開したのでDynamoDBとか使っちゃう.md","raw":"---\ntitle: Kotlin + AWS Lambda + API GatewayでServerlessできちゃうラッパー公開したのでDynamoDBとか使っちゃう\npermalink: 1\ndate: 2016-12-11 12:36:08\ntags:\n---\n\nタイトルの通りです。[githubに置いてある](https://github.com/tottokotkd/GatewayHandler)し、[Bintray経由でjcenterにもある](https://bintray.com/bintray/jcenter?filterByPkgName=GatewayHandler)ので使えます。この公開ルートは今回初めてやってみましたが、なかなか便利ですね。\n\nもちろん公開するだけならgithubページでもイケるんですけど、その作業が手間だったり、IntelliJくんがキャッシュ持つ段階でエラー吐いたり、面倒なのでBintrayです。今はあんまりそこを頑張りたくなかった、仕方なかった。\n\ngithubの方に書いてあるんですけど、コードでいうとこんな感じ。\n\n```kotlin\npackage hello\n\nimport com.amazonaws.regions.Regions\nimport com.amazonaws.services.dynamodbv2.document.DynamoDB\nimport com.amazonaws.services.dynamodbv2.document.Item\nimport com.amazonaws.services.lambda.runtime.Context\nimport com.tottokotkd.aws.gateway.core.*\nimport java.time.ZonedDateTime\nimport java.time.format.DateTimeFormatter\nimport kotlin.properties.Delegates\n\nclass SaveRequest {\n    lateinit var user: String\n    lateinit var url: String\n    var rate: Int by Delegates.notNull()\n    lateinit var timestamp: String\n}\n\nclass SaveHandler: DataHandler<SaveRequest, Any> {\n    override fun handleRequest(input: SaveRequest, context: Context): ResponseData<Any> {\n\n        val timestamp = try {\n            ZonedDateTime.parse(input.timestamp, DateTimeFormatter.ISO_DATE_TIME)\n        } catch (e: Exception) {\n            return ResponseData(mapOf(\"status\" to \"error\", \"desc\" to \"date time parsing failed.\"), StatusCode.BadRequest)\n        }\n\n        val dynamoDB = DynamoDB(Regions.US_EAST_1)\n        val t = dynamoDB.getTable(\"pages\")\n        val item = Item.fromMap(mapOf(\"user\" to input.user, \"url\" to input.url, \"rate\" to input.rate, \"epoch\" to timestamp.toEpochSecond(), \"timezone\" to timestamp.offset.totalSeconds))\n        val result = t.putItem(item)\n\n        return ResponseData(mapOf(\"status\" to \"success\", \"input\" to input))\n    }\n}\n```\n\n`SaveHandler`がリクエストハンドラーで、`SaveRequest`がリクエストに期待される内容ですね。言うまでもないか。\n\nAPI Gateway経由なのでJSONを渡されそうなものですが、実際はアマゾンがPOJOに突っ込んだうえで渡してくれます。Serverlessの設定として書くべきことも特になくて、本当にこのままLambdaにデプロイすれば面倒をみてくれます。DynamoDBもIAMさえ弄ればコードは1行で終わり。たったこれだけで (金さえ払えば) 無敵のスケーラビリティが手に入っちゃう。スゴイ！\n\nただしアマゾン様といえどもdata classのコンストラクタを使うような器用な芸当は当然やれないので、`SaveRequest`はプロパティ全てvarのクラスになっています。もっともここは`val hoge: String by Delegates.notNull()` の方がいいような気もするし、Web APIなんだから`String?`の方がかえってロジカルに書きやすいような気もするし、その辺りは僕もまだ深く考えてません。そこまでkotlinやAWSの挙動に詳しくないという事情もある。\n\nそれはともかく戻り値が`Any`になっていて許せん！という人もいると思いますが、これはmapOfで手軽に返したかったのです。データクラスとか指定すればちゃんと型安全で動きます (たぶん)。\n\nまあこの辺りは趣味の問題でもあり、生産性を上げるために工夫のしどころだとも思うので、`ResponseData`を使わず自前で実装する方がいいかもですね、ステータスコードは引数じゃなくて型に結びつけるとか。あるいはハンドラーの方にヘルパーをバシバシ生やすとか… その辺は今後ちょっと便利になったらいいかなあ。フォークしてPRで見せびらかしてくれる人とか出てきたら嬉しい。\n\n\n\nで、コードはもう特に書くことないので思い出をつらつらと。\n\n## API Gateway -> Lambda -> Error!\n\n`sls invoke -f hello` が動くぞ！やったー！などと隙を見せたエンジニアを強襲するAWS！\n\n> Malformed Lambda proxy response\n\nlambdaとしては呼べるけどcurlすると落ちる。\n\nServerless使って一番つらかったのはコレ。Kotlin + Serverless + API Gatewayなんて実際に使っているケースがほぼ見つからない上に、ちょっと古い記事だと「動きました！簡単」とか書いてあるコードが今はもう動かない。嘘だゾ、全然簡単じゃないゾ。\n\n\nということで頑張って検索して探したのがコレ。~~人柱サンキュー！~~\n\n{% blockquote kyl191 https://forums.aws.amazon.com/thread.jspa?threadID=239688 AWS Developer Forums: Lambda Proxy Expectations %}\nOk, I found some documentation which says it expects statusCode, body and headers in a dict.\n{% endblockquote %}\n\n何でこんな状態なのか、ちょっと意味が分からないんですけど、API Gateway (Lambda Proxy) から呼ばれるLambdaは**戻り値の型はどうでもいいしインターフェイスとかないけど、statusCode body headersという3つの値を持っていないと実行時エラーになる**という凡そJavaとは思われない動的な仕組みになっているみたいです。\n\nつまり、'sls invoke -f hello'の結果として\n\n```json\n{\"hage\": [\"ok\", \"cool\", \"amazing\"]}\n```\n\nみたいな結果が見えている場合はダメです。\n\nLambdaとしては動いているのですが、Gateway経由で呼びたいなら以下の内容でなければいけません。\n\n\n```json\n{\n    \"body\": {\n        \"hage\": [\"ok\", \"cool\", \"amazing\"]\n    },\n    \"headers\": {},\n    \"statusCode\": 400\n}\n```\n\nこのフォーマットを守らなければ、Lambda ProxyモードのAPI Gatewayは有効な結果として受け付けてくれないのです。理屈が分かってしまえば納得できますが、この落とし穴だけは本当にひどい罠だと思います。\n\n一旦Lambda側からJSONを出力した上で、それを改めてGateway側がチェックするんでしょうか？ 色々と想像してますが謎です。\n\nちなみにデータのJSON化はあっちがJacksonでやってくれるので、上記のようなプロパティを持つPOJOを投げればいいみたいです。kotlinならdata classですね。あと試していませんがmapでも大丈夫かなと。\n\nただまあ、そこを自由にしても特に利点がなさそうなうえ、誰の目にも明らかにバグの温床でしかありません。今回のラッパーでは3つのプロパティを明示的に要求するインターフェイスを作っておきました。そもそも本来こういう仕様になってなきゃJavaコードとしておかしいと思うんですけど、それはそれで公式SDKとしては狭すぎる感じもありますからね… まあ気持ちはわかります。クソですけど。\n\nLambdaプロキシ自体が割と新しい機能であることも考えると仕方ない、AWSはこういうものなのだ… と割り切りましょう。\n\n## 2つの型パラメータを持つジェネリッククラスでないとエラーになる\n\nもうエラーログが手元にないんですが、リクエストハンドラーとして型パラメータ1つのクラスを作ってみたら「型パラメータは2つないと困るんだよなァ！」みたいな激おこメッセージを飛ばしてきました。これまたちょっと意味が分からないんですけど、JSONをリクエストPOJOに変換するときに型パラメータを使おうとしているのかな？ とにかくダメなものはダメらしいです。\n\nそれにしたって型パラメータ2つじゃないとダメっておかしくねえか？設計どうなってんの？という気もしますが仕方ない、AWSはこういうものなのだ… と割り切りましょう。\n\n## Internal Server Error\nAPI Gatewayを通過して結果が戻ってくるまでの間にエラーが発生するとInternal Server Errorです。例えば「Lambda処理内でリクエストパラメータを参照したらnull例外で落ちた」とかいう場合、それはInternal Server Errorであり、Gatewayのデフォルト処理が走って超ダサいJSONを投げ返します。\n\nサーバー内部でエラーが発生するなら、API Gatewayの視点からは全てInternal Server Errorなのです。まあそりゃ当然の挙動なんですけど、それはAPIを書く側からするとBadRequestだし、そもそも勝手にダサいJSONを流されるのも困ります。\n\nということでつまり、ハンドラ全体をtryで囲わないと不安だし、リクエスト内容の処理もちゃんと書かないといけません。当たり前の話とはいえ若干ちょっと面倒そう…\n\nその辺りをうまく集約できるインターフェイスとか作らないと大変そうですね。まあもちろん「ステータスコードさえ取れるなら大丈夫、後はYAGNI」という考え方もあると思います。その辺りの線引きはちょっと難しそう。\n\n## ということで\n\nなんか動くものは作れそうだし頑張る。","slug":"1","published":1,"updated":"2016-12-11T06:05:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwk8xwbv0000dzc1fvexhn95","content":"<p>タイトルの通りです。<a href=\"https://github.com/tottokotkd/GatewayHandler\" target=\"_blank\" rel=\"external\">githubに置いてある</a>し、<a href=\"https://bintray.com/bintray/jcenter?filterByPkgName=GatewayHandler\" target=\"_blank\" rel=\"external\">Bintray経由でjcenterにもある</a>ので使えます。この公開ルートは今回初めてやってみましたが、なかなか便利ですね。</p>\n<p>もちろん公開するだけならgithubページでもイケるんですけど、その作業が手間だったり、IntelliJくんがキャッシュ持つ段階でエラー吐いたり、面倒なのでBintrayです。今はあんまりそこを頑張りたくなかった、仕方なかった。</p>\n<p>githubの方に書いてあるんですけど、コードでいうとこんな感じ。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> hello</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.regions.Regions</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.dynamodbv2.document.DynamoDB</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.dynamodbv2.document.Item</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.lambda.runtime.Context</div><div class=\"line\"><span class=\"keyword\">import</span> com.tottokotkd.aws.gateway.core.*</div><div class=\"line\"><span class=\"keyword\">import</span> java.time.ZonedDateTime</div><div class=\"line\"><span class=\"keyword\">import</span> java.time.format.DateTimeFormatter</div><div class=\"line\"><span class=\"keyword\">import</span> kotlin.properties.Delegates</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveRequest</span> </span>&#123;</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> user: String</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> url: String</div><div class=\"line\">    <span class=\"keyword\">var</span> rate: <span class=\"built_in\">Int</span> <span class=\"keyword\">by</span> Delegates.notNull()</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> timestamp: String</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveHandler</span>: <span class=\"type\">DataHandler</span>&lt;<span class=\"type\">SaveRequest, Any</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">handleRequest</span><span class=\"params\">(input: <span class=\"type\">SaveRequest</span>, context: <span class=\"type\">Context</span>)</span></span>: ResponseData&lt;Any&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">val</span> timestamp = <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            ZonedDateTime.parse(input.timestamp, DateTimeFormatter.ISO_DATE_TIME)</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ResponseData(mapOf(<span class=\"string\">\"status\"</span> to <span class=\"string\">\"error\"</span>, <span class=\"string\">\"desc\"</span> to <span class=\"string\">\"date time parsing failed.\"</span>), StatusCode.BadRequest)</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">val</span> dynamoDB = DynamoDB(Regions.US_EAST_1)</div><div class=\"line\">        <span class=\"keyword\">val</span> t = dynamoDB.getTable(<span class=\"string\">\"pages\"</span>)</div><div class=\"line\">        <span class=\"keyword\">val</span> item = Item.fromMap(mapOf(<span class=\"string\">\"user\"</span> to input.user, <span class=\"string\">\"url\"</span> to input.url, <span class=\"string\">\"rate\"</span> to input.rate, <span class=\"string\">\"epoch\"</span> to timestamp.toEpochSecond(), <span class=\"string\">\"timezone\"</span> to timestamp.offset.totalSeconds))</div><div class=\"line\">        <span class=\"keyword\">val</span> result = t.putItem(item)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> ResponseData(mapOf(<span class=\"string\">\"status\"</span> to <span class=\"string\">\"success\"</span>, <span class=\"string\">\"input\"</span> to input))</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>SaveHandler</code>がリクエストハンドラーで、<code>SaveRequest</code>がリクエストに期待される内容ですね。言うまでもないか。</p>\n<p>API Gateway経由なのでJSONを渡されそうなものですが、実際はアマゾンがPOJOに突っ込んだうえで渡してくれます。Serverlessの設定として書くべきことも特になくて、本当にこのままLambdaにデプロイすれば面倒をみてくれます。DynamoDBもIAMさえ弄ればコードは1行で終わり。たったこれだけで (金さえ払えば) 無敵のスケーラビリティが手に入っちゃう。スゴイ！</p>\n<p>ただしアマゾン様といえどもdata classのコンストラクタを使うような器用な芸当は当然やれないので、<code>SaveRequest</code>はプロパティ全てvarのクラスになっています。もっともここは<code>val hoge: String by Delegates.notNull()</code> の方がいいような気もするし、Web APIなんだから<code>String?</code>の方がかえってロジカルに書きやすいような気もするし、その辺りは僕もまだ深く考えてません。そこまでkotlinやAWSの挙動に詳しくないという事情もある。</p>\n<p>それはともかく戻り値が<code>Any</code>になっていて許せん！という人もいると思いますが、これはmapOfで手軽に返したかったのです。データクラスとか指定すればちゃんと型安全で動きます (たぶん)。</p>\n<p>まあこの辺りは趣味の問題でもあり、生産性を上げるために工夫のしどころだとも思うので、<code>ResponseData</code>を使わず自前で実装する方がいいかもですね、ステータスコードは引数じゃなくて型に結びつけるとか。あるいはハンドラーの方にヘルパーをバシバシ生やすとか… その辺は今後ちょっと便利になったらいいかなあ。フォークしてPRで見せびらかしてくれる人とか出てきたら嬉しい。</p>\n<p>で、コードはもう特に書くことないので思い出をつらつらと。</p>\n<h2 id=\"API-Gateway-gt-Lambda-gt-Error\"><a href=\"#API-Gateway-gt-Lambda-gt-Error\" class=\"headerlink\" title=\"API Gateway -&gt; Lambda -&gt; Error!\"></a>API Gateway -&gt; Lambda -&gt; Error!</h2><p><code>sls invoke -f hello</code> が動くぞ！やったー！などと隙を見せたエンジニアを強襲するAWS！</p>\n<blockquote>\n<p>Malformed Lambda proxy response</p>\n</blockquote>\n<p>lambdaとしては呼べるけどcurlすると落ちる。</p>\n<p>Serverless使って一番つらかったのはコレ。Kotlin + Serverless + API Gatewayなんて実際に使っているケースがほぼ見つからない上に、ちょっと古い記事だと「動きました！簡単」とか書いてあるコードが今はもう動かない。嘘だゾ、全然簡単じゃないゾ。</p>\n<p>ということで頑張って検索して探したのがコレ。<del>人柱サンキュー！</del></p>\n<blockquote><p>Ok, I found some documentation which says it expects statusCode, body and headers in a dict.</p>\n<footer><strong>kyl191</strong><cite><a href=\"https://forums.aws.amazon.com/thread.jspa?threadID=239688\" target=\"_blank\" rel=\"external\">AWS Developer Forums: Lambda Proxy Expectations</a></cite></footer></blockquote>\n<p>何でこんな状態なのか、ちょっと意味が分からないんですけど、API Gateway (Lambda Proxy) から呼ばれるLambdaは<strong>戻り値の型はどうでもいいしインターフェイスとかないけど、statusCode body headersという3つの値を持っていないと実行時エラーになる</strong>という凡そJavaとは思われない動的な仕組みになっているみたいです。</p>\n<p>つまり、’sls invoke -f hello’の結果として</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;<span class=\"attr\">\"hage\"</span>: [<span class=\"string\">\"ok\"</span>, <span class=\"string\">\"cool\"</span>, <span class=\"string\">\"amazing\"</span>]&#125;</div></pre></td></tr></table></figure>\n<p>みたいな結果が見えている場合はダメです。</p>\n<p>Lambdaとしては動いているのですが、Gateway経由で呼びたいなら以下の内容でなければいけません。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"body\"</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">\"hage\"</span>: [<span class=\"string\">\"ok\"</span>, <span class=\"string\">\"cool\"</span>, <span class=\"string\">\"amazing\"</span>]</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"headers\"</span>: &#123;&#125;,</div><div class=\"line\">    <span class=\"attr\">\"statusCode\"</span>: <span class=\"number\">400</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>このフォーマットを守らなければ、Lambda ProxyモードのAPI Gatewayは有効な結果として受け付けてくれないのです。理屈が分かってしまえば納得できますが、この落とし穴だけは本当にひどい罠だと思います。</p>\n<p>一旦Lambda側からJSONを出力した上で、それを改めてGateway側がチェックするんでしょうか？ 色々と想像してますが謎です。</p>\n<p>ちなみにデータのJSON化はあっちがJacksonでやってくれるので、上記のようなプロパティを持つPOJOを投げればいいみたいです。kotlinならdata classですね。あと試していませんがmapでも大丈夫かなと。</p>\n<p>ただまあ、そこを自由にしても特に利点がなさそうなうえ、誰の目にも明らかにバグの温床でしかありません。今回のラッパーでは3つのプロパティを明示的に要求するインターフェイスを作っておきました。そもそも本来こういう仕様になってなきゃJavaコードとしておかしいと思うんですけど、それはそれで公式SDKとしては狭すぎる感じもありますからね… まあ気持ちはわかります。クソですけど。</p>\n<p>Lambdaプロキシ自体が割と新しい機能であることも考えると仕方ない、AWSはこういうものなのだ… と割り切りましょう。</p>\n<h2 id=\"2つの型パラメータを持つジェネリッククラスでないとエラーになる\"><a href=\"#2つの型パラメータを持つジェネリッククラスでないとエラーになる\" class=\"headerlink\" title=\"2つの型パラメータを持つジェネリッククラスでないとエラーになる\"></a>2つの型パラメータを持つジェネリッククラスでないとエラーになる</h2><p>もうエラーログが手元にないんですが、リクエストハンドラーとして型パラメータ1つのクラスを作ってみたら「型パラメータは2つないと困るんだよなァ！」みたいな激おこメッセージを飛ばしてきました。これまたちょっと意味が分からないんですけど、JSONをリクエストPOJOに変換するときに型パラメータを使おうとしているのかな？ とにかくダメなものはダメらしいです。</p>\n<p>それにしたって型パラメータ2つじゃないとダメっておかしくねえか？設計どうなってんの？という気もしますが仕方ない、AWSはこういうものなのだ… と割り切りましょう。</p>\n<h2 id=\"Internal-Server-Error\"><a href=\"#Internal-Server-Error\" class=\"headerlink\" title=\"Internal Server Error\"></a>Internal Server Error</h2><p>API Gatewayを通過して結果が戻ってくるまでの間にエラーが発生するとInternal Server Errorです。例えば「Lambda処理内でリクエストパラメータを参照したらnull例外で落ちた」とかいう場合、それはInternal Server Errorであり、Gatewayのデフォルト処理が走って超ダサいJSONを投げ返します。</p>\n<p>サーバー内部でエラーが発生するなら、API Gatewayの視点からは全てInternal Server Errorなのです。まあそりゃ当然の挙動なんですけど、それはAPIを書く側からするとBadRequestだし、そもそも勝手にダサいJSONを流されるのも困ります。</p>\n<p>ということでつまり、ハンドラ全体をtryで囲わないと不安だし、リクエスト内容の処理もちゃんと書かないといけません。当たり前の話とはいえ若干ちょっと面倒そう…</p>\n<p>その辺りをうまく集約できるインターフェイスとか作らないと大変そうですね。まあもちろん「ステータスコードさえ取れるなら大丈夫、後はYAGNI」という考え方もあると思います。その辺りの線引きはちょっと難しそう。</p>\n<h2 id=\"ということで\"><a href=\"#ということで\" class=\"headerlink\" title=\"ということで\"></a>ということで</h2><p>なんか動くものは作れそうだし頑張る。</p>\n","excerpt":"","more":"<p>タイトルの通りです。<a href=\"https://github.com/tottokotkd/GatewayHandler\">githubに置いてある</a>し、<a href=\"https://bintray.com/bintray/jcenter?filterByPkgName=GatewayHandler\">Bintray経由でjcenterにもある</a>ので使えます。この公開ルートは今回初めてやってみましたが、なかなか便利ですね。</p>\n<p>もちろん公開するだけならgithubページでもイケるんですけど、その作業が手間だったり、IntelliJくんがキャッシュ持つ段階でエラー吐いたり、面倒なのでBintrayです。今はあんまりそこを頑張りたくなかった、仕方なかった。</p>\n<p>githubの方に書いてあるんですけど、コードでいうとこんな感じ。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> hello</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.regions.Regions</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.dynamodbv2.document.DynamoDB</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.dynamodbv2.document.Item</div><div class=\"line\"><span class=\"keyword\">import</span> com.amazonaws.services.lambda.runtime.Context</div><div class=\"line\"><span class=\"keyword\">import</span> com.tottokotkd.aws.gateway.core.*</div><div class=\"line\"><span class=\"keyword\">import</span> java.time.ZonedDateTime</div><div class=\"line\"><span class=\"keyword\">import</span> java.time.format.DateTimeFormatter</div><div class=\"line\"><span class=\"keyword\">import</span> kotlin.properties.Delegates</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveRequest</span> </span>&#123;</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> user: String</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> url: String</div><div class=\"line\">    <span class=\"keyword\">var</span> rate: <span class=\"built_in\">Int</span> <span class=\"keyword\">by</span> Delegates.notNull()</div><div class=\"line\">    lateinit <span class=\"keyword\">var</span> timestamp: String</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveHandler</span>: <span class=\"type\">DataHandler</span>&lt;<span class=\"type\">SaveRequest, Any</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">handleRequest</span><span class=\"params\">(input: <span class=\"type\">SaveRequest</span>, context: <span class=\"type\">Context</span>)</span></span>: ResponseData&lt;Any&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">val</span> timestamp = <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            ZonedDateTime.parse(input.timestamp, DateTimeFormatter.ISO_DATE_TIME)</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ResponseData(mapOf(<span class=\"string\">\"status\"</span> to <span class=\"string\">\"error\"</span>, <span class=\"string\">\"desc\"</span> to <span class=\"string\">\"date time parsing failed.\"</span>), StatusCode.BadRequest)</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">val</span> dynamoDB = DynamoDB(Regions.US_EAST_1)</div><div class=\"line\">        <span class=\"keyword\">val</span> t = dynamoDB.getTable(<span class=\"string\">\"pages\"</span>)</div><div class=\"line\">        <span class=\"keyword\">val</span> item = Item.fromMap(mapOf(<span class=\"string\">\"user\"</span> to input.user, <span class=\"string\">\"url\"</span> to input.url, <span class=\"string\">\"rate\"</span> to input.rate, <span class=\"string\">\"epoch\"</span> to timestamp.toEpochSecond(), <span class=\"string\">\"timezone\"</span> to timestamp.offset.totalSeconds))</div><div class=\"line\">        <span class=\"keyword\">val</span> result = t.putItem(item)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> ResponseData(mapOf(<span class=\"string\">\"status\"</span> to <span class=\"string\">\"success\"</span>, <span class=\"string\">\"input\"</span> to input))</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>SaveHandler</code>がリクエストハンドラーで、<code>SaveRequest</code>がリクエストに期待される内容ですね。言うまでもないか。</p>\n<p>API Gateway経由なのでJSONを渡されそうなものですが、実際はアマゾンがPOJOに突っ込んだうえで渡してくれます。Serverlessの設定として書くべきことも特になくて、本当にこのままLambdaにデプロイすれば面倒をみてくれます。DynamoDBもIAMさえ弄ればコードは1行で終わり。たったこれだけで (金さえ払えば) 無敵のスケーラビリティが手に入っちゃう。スゴイ！</p>\n<p>ただしアマゾン様といえどもdata classのコンストラクタを使うような器用な芸当は当然やれないので、<code>SaveRequest</code>はプロパティ全てvarのクラスになっています。もっともここは<code>val hoge: String by Delegates.notNull()</code> の方がいいような気もするし、Web APIなんだから<code>String?</code>の方がかえってロジカルに書きやすいような気もするし、その辺りは僕もまだ深く考えてません。そこまでkotlinやAWSの挙動に詳しくないという事情もある。</p>\n<p>それはともかく戻り値が<code>Any</code>になっていて許せん！という人もいると思いますが、これはmapOfで手軽に返したかったのです。データクラスとか指定すればちゃんと型安全で動きます (たぶん)。</p>\n<p>まあこの辺りは趣味の問題でもあり、生産性を上げるために工夫のしどころだとも思うので、<code>ResponseData</code>を使わず自前で実装する方がいいかもですね、ステータスコードは引数じゃなくて型に結びつけるとか。あるいはハンドラーの方にヘルパーをバシバシ生やすとか… その辺は今後ちょっと便利になったらいいかなあ。フォークしてPRで見せびらかしてくれる人とか出てきたら嬉しい。</p>\n<p>で、コードはもう特に書くことないので思い出をつらつらと。</p>\n<h2 id=\"API-Gateway-gt-Lambda-gt-Error\"><a href=\"#API-Gateway-gt-Lambda-gt-Error\" class=\"headerlink\" title=\"API Gateway -&gt; Lambda -&gt; Error!\"></a>API Gateway -&gt; Lambda -&gt; Error!</h2><p><code>sls invoke -f hello</code> が動くぞ！やったー！などと隙を見せたエンジニアを強襲するAWS！</p>\n<blockquote>\n<p>Malformed Lambda proxy response</p>\n</blockquote>\n<p>lambdaとしては呼べるけどcurlすると落ちる。</p>\n<p>Serverless使って一番つらかったのはコレ。Kotlin + Serverless + API Gatewayなんて実際に使っているケースがほぼ見つからない上に、ちょっと古い記事だと「動きました！簡単」とか書いてあるコードが今はもう動かない。嘘だゾ、全然簡単じゃないゾ。</p>\n<p>ということで頑張って検索して探したのがコレ。<del>人柱サンキュー！</del></p>\n<blockquote><p>Ok, I found some documentation which says it expects statusCode, body and headers in a dict.</p>\n<footer><strong>kyl191</strong><cite><a href=\"https://forums.aws.amazon.com/thread.jspa?threadID=239688\">AWS Developer Forums: Lambda Proxy Expectations</a></cite></footer></blockquote>\n<p>何でこんな状態なのか、ちょっと意味が分からないんですけど、API Gateway (Lambda Proxy) から呼ばれるLambdaは<strong>戻り値の型はどうでもいいしインターフェイスとかないけど、statusCode body headersという3つの値を持っていないと実行時エラーになる</strong>という凡そJavaとは思われない動的な仕組みになっているみたいです。</p>\n<p>つまり、’sls invoke -f hello’の結果として</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;<span class=\"attr\">\"hage\"</span>: [<span class=\"string\">\"ok\"</span>, <span class=\"string\">\"cool\"</span>, <span class=\"string\">\"amazing\"</span>]&#125;</div></pre></td></tr></table></figure>\n<p>みたいな結果が見えている場合はダメです。</p>\n<p>Lambdaとしては動いているのですが、Gateway経由で呼びたいなら以下の内容でなければいけません。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"body\"</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">\"hage\"</span>: [<span class=\"string\">\"ok\"</span>, <span class=\"string\">\"cool\"</span>, <span class=\"string\">\"amazing\"</span>]</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"headers\"</span>: &#123;&#125;,</div><div class=\"line\">    <span class=\"attr\">\"statusCode\"</span>: <span class=\"number\">400</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>このフォーマットを守らなければ、Lambda ProxyモードのAPI Gatewayは有効な結果として受け付けてくれないのです。理屈が分かってしまえば納得できますが、この落とし穴だけは本当にひどい罠だと思います。</p>\n<p>一旦Lambda側からJSONを出力した上で、それを改めてGateway側がチェックするんでしょうか？ 色々と想像してますが謎です。</p>\n<p>ちなみにデータのJSON化はあっちがJacksonでやってくれるので、上記のようなプロパティを持つPOJOを投げればいいみたいです。kotlinならdata classですね。あと試していませんがmapでも大丈夫かなと。</p>\n<p>ただまあ、そこを自由にしても特に利点がなさそうなうえ、誰の目にも明らかにバグの温床でしかありません。今回のラッパーでは3つのプロパティを明示的に要求するインターフェイスを作っておきました。そもそも本来こういう仕様になってなきゃJavaコードとしておかしいと思うんですけど、それはそれで公式SDKとしては狭すぎる感じもありますからね… まあ気持ちはわかります。クソですけど。</p>\n<p>Lambdaプロキシ自体が割と新しい機能であることも考えると仕方ない、AWSはこういうものなのだ… と割り切りましょう。</p>\n<h2 id=\"2つの型パラメータを持つジェネリッククラスでないとエラーになる\"><a href=\"#2つの型パラメータを持つジェネリッククラスでないとエラーになる\" class=\"headerlink\" title=\"2つの型パラメータを持つジェネリッククラスでないとエラーになる\"></a>2つの型パラメータを持つジェネリッククラスでないとエラーになる</h2><p>もうエラーログが手元にないんですが、リクエストハンドラーとして型パラメータ1つのクラスを作ってみたら「型パラメータは2つないと困るんだよなァ！」みたいな激おこメッセージを飛ばしてきました。これまたちょっと意味が分からないんですけど、JSONをリクエストPOJOに変換するときに型パラメータを使おうとしているのかな？ とにかくダメなものはダメらしいです。</p>\n<p>それにしたって型パラメータ2つじゃないとダメっておかしくねえか？設計どうなってんの？という気もしますが仕方ない、AWSはこういうものなのだ… と割り切りましょう。</p>\n<h2 id=\"Internal-Server-Error\"><a href=\"#Internal-Server-Error\" class=\"headerlink\" title=\"Internal Server Error\"></a>Internal Server Error</h2><p>API Gatewayを通過して結果が戻ってくるまでの間にエラーが発生するとInternal Server Errorです。例えば「Lambda処理内でリクエストパラメータを参照したらnull例外で落ちた」とかいう場合、それはInternal Server Errorであり、Gatewayのデフォルト処理が走って超ダサいJSONを投げ返します。</p>\n<p>サーバー内部でエラーが発生するなら、API Gatewayの視点からは全てInternal Server Errorなのです。まあそりゃ当然の挙動なんですけど、それはAPIを書く側からするとBadRequestだし、そもそも勝手にダサいJSONを流されるのも困ります。</p>\n<p>ということでつまり、ハンドラ全体をtryで囲わないと不安だし、リクエスト内容の処理もちゃんと書かないといけません。当たり前の話とはいえ若干ちょっと面倒そう…</p>\n<p>その辺りをうまく集約できるインターフェイスとか作らないと大変そうですね。まあもちろん「ステータスコードさえ取れるなら大丈夫、後はYAGNI」という考え方もあると思います。その辺りの線引きはちょっと難しそう。</p>\n<h2 id=\"ということで\"><a href=\"#ということで\" class=\"headerlink\" title=\"ということで\"></a>ということで</h2><p>なんか動くものは作れそうだし頑張る。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciwk8sff70000dtc1ilq97zad","tag_id":"ciwk8sfff0002dtc1nnpk774o","_id":"ciwk8sffp0007dtc1yyknqars"},{"post_id":"ciwk8sffd0001dtc1ilp3owlw","tag_id":"ciwk8sffo0006dtc1gpo95qtq","_id":"ciwk8sfft000cdtc1xyb2l1oe"},{"post_id":"ciwk8sffd0001dtc1ilp3owlw","tag_id":"ciwk8sffr0008dtc1xfb0aytm","_id":"ciwk8sffu000ddtc15j6ox6v8"},{"post_id":"ciwk8sffd0001dtc1ilp3owlw","tag_id":"ciwk8sffr0009dtc12gw0ch0m","_id":"ciwk8sffu000fdtc11ilrlyng"},{"post_id":"ciwk8sffd0001dtc1ilp3owlw","tag_id":"ciwk8sffs000adtc1sah7pj78","_id":"ciwk8sffv000gdtc1jrac367z"},{"post_id":"ciwk8sffl0005dtc190ysrg7o","tag_id":"ciwk8sffo0006dtc1gpo95qtq","_id":"ciwk8sffw000idtc1bp3gjh90"},{"post_id":"ciwk8sffl0005dtc190ysrg7o","tag_id":"ciwk8sffu000edtc1gkbehwak","_id":"ciwk8sffw000jdtc1qbue6kyv"},{"post_id":"ciwk8sffl0005dtc190ysrg7o","tag_id":"ciwk8sffv000hdtc1bptcuvxm","_id":"ciwk8sffw000kdtc1udxbys9z"},{"post_id":"ciwk8sffk0004dtc1hn9adtcl","tag_id":"ciwk91zh70000hzc17v71jtlc","_id":"ciwk91zhd0002hzc1yykfga4o"},{"post_id":"ciwk8sffk0004dtc1hn9adtcl","tag_id":"ciwk91zhc0001hzc1lfdk8uon","_id":"ciwk91zhe0003hzc1j6fb9zoc"}],"Tag":[{"name":"Gulp","_id":"ciwk8sfff0002dtc1nnpk774o"},{"name":"Swift","_id":"ciwk8sffo0006dtc1gpo95qtq"},{"name":"Kitura","_id":"ciwk8sffr0008dtc1xfb0aytm"},{"name":"MariaDB","_id":"ciwk8sffr0009dtc12gw0ch0m"},{"name":"Sterntaler","_id":"ciwk8sffs000adtc1sah7pj78"},{"name":"CLion","_id":"ciwk8sffu000edtc1gkbehwak"},{"name":"CMake","_id":"ciwk8sffv000hdtc1bptcuvxm"},{"name":"Kotlin","_id":"ciwk91zh70000hzc17v71jtlc"},{"name":"AWS","_id":"ciwk91zhc0001hzc1lfdk8uon"}]}}